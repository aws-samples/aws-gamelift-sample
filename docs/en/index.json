[
{
	"uri": "/aws-gamelift-sample/en/awsservice/lab10/",
	"title": "Deploy CloudFormation Stack",
	"tags": [],
	"description": "",
	"content": "Automate AWS resources with CloudFormation In this page, it is able to create AWS services for this lab with CloudFormation Stack. It is useful to prevent errors or misconfigurations by this Automated Stack, and also proper to start GameLift HoL quickly. If you finish CloudFormation Stack deployment, you are able to proceed to next part.\nAccess to CloudFormation console of your region. (https://ap-northeast-2.console.aws.amazon.com/cloudformation)\nFind \u0026ldquo;GomokuHoLTemplate.json\u0026rdquo; file on your source files. This file is included in Folder \u0026ldquo;CloudFormation\u0026rdquo;.\nClick \u0026ldquo;Create Stack\u0026rdquo; on CloudFormation Console. And select Template is ready \u0026gt; Upload a template File. Upload GomokuHoLTemplate.json.\nIf you check \u0026ldquo;View in Designer\u0026rdquo;, you can check CloudFormation Stack like below. It is easy to configure automated stacks using CloudFormation. Input Stack name \u0026ldquo;GameLiftHoL\u0026rdquo;.\nCreate stack as follows. Please check resource is deployed successfully like below.\nIf resource with same name already exists in same region, it is not able to make resource. If same resources are remained, retry deployment after deleting remained resources. After creating AWS services with CloudFormation Stacks, you can skip lab-1. Move on to the next part\n"
},
{
	"uri": "/aws-gamelift-sample/en/",
	"title": "GameLift HoL",
	"tags": [],
	"description": "",
	"content": "Start Full Stack Game with GameLift It has been a long time to develop your game. And Finally\u0026hellip; it is time to launch! \u0026ldquo;Gomoku\u0026rdquo; is traditional board game that is playing with two stones, black and white.\nTwo players put their stones on the board, make a line with 5 stones, and win the game. Before launch your game, you found the issue. Oh my god! We cannot play \u0026ldquo;Gomoku\u0026rdquo; alone! You decided to make game playable via internet. And you found that AWS Services can help this.\nEspecially with GameLift, You found that it is easy to make session based game.\nGame is already given, and you can start this job easily with this Hands on Lab. In this lab, we are trying to make Full Stack Game based on GameLift with Serverless and Managed Services.\nToday\u0026rsquo;s Demo This is the game we make. It seems interesting! Let\u0026rsquo;s start making the game step by step.\n"
},
{
	"uri": "/aws-gamelift-sample/en/awsservice/lab11/",
	"title": "Creating DynamoDB",
	"tags": [],
	"description": "",
	"content": "Creating DynamoDB This lab uses DynamoDB to store User data and Game result. We are going to store simple information, and this information will be used to Leaderboard on our static web page.\nAdditionally, we will use ElastiCache in front of DynamoDB for caching. Because your game \u0026ldquo;Gomoku\u0026rdquo; will be very popular, so we need cache layer for performance and reliability!\nFirst things first, let\u0026rsquo;s make DynamoDB first.\nLogin to AWS Console and move to DynamoDB page (https://console.aws.amazon.com/dynamodb) Check region. Every resources on this lab should be launched on same region. Click \u0026ldquo;Create Table\u0026rdquo; to make DynamoDB Table. Set Table name as “GomokuPlayerInfo”, and Primary Key \u0026ldquo;PlayerName\u0026rdquo;. Make data type as \u0026ldquo;String\u0026rdquo;. Let\u0026rsquo;s click \u0026ldquo;Create button\u0026rdquo;.\nEnable “Stream” on your DynamoDB Table. It is disabled as default, so select \u0026ldquo;Exports and streams\u0026rdquo; tab and click \u0026ldquo;Enable\u0026rdquo; button on DynamoDB stream details.\nSelect \u0026ldquo;New and old images\u0026rdquo;, and Click \u0026ldquo;Enable\u0026rdquo; button on the box. Basic configuration is ended. Let\u0026rsquo;s make Test Data Sample. Click \u0026ldquo;Explore table Items\u0026rdquo; in the upper right corner.\nClick \u0026ldquo;Create Item\u0026rdquo;, and make new Item.\nClick Create Item button on the editor, and append item.\nPut data on your new item same as below. Click \u0026ldquo;Create Item\u0026rdquo; to store Item. (Check the data type)\nYou can find this Item on the table, when you select table GomokuPlayerInfo and click run on Scan/Query items search items from this table. Ok. This is Basic settings of DynamoDB. Nextly we are making ElastiCache.\n"
},
{
	"uri": "/aws-gamelift-sample/en/intro/",
	"title": "GameLift HoL Introduction",
	"tags": [],
	"description": "",
	"content": "Start Full Stack Game with GameLift It has been a long time to develop your game. And Finally\u0026hellip; it is time to launch! \u0026ldquo;Gomoku\u0026rdquo; is traditional board game that is playing with two stones, black and white.\nTwo players put their stones on the board, make a line with 5 stones, and win the game. Before launch your game, you found the issue. Oh my god! We cannot play \u0026ldquo;Gomoku\u0026rdquo; alone! You decided to make game playable via internet. And you found that AWS Services can help this.\nEspecially with GameLift, You found that it is easy to make session based game.\nGame is already given, and you can start this job easily with this Hands on Lab. In this lab, we are trying to make Full Stack Game based on GameLift with Serverless and Managed Services.\nToday\u0026rsquo;s Demo This is the game we make. It seems interesting! Let\u0026rsquo;s start making the game step by step.\n"
},
{
	"uri": "/aws-gamelift-sample/en/flexmatch/lab21/",
	"title": "Making Lambda Functions",
	"tags": [],
	"description": "",
	"content": "\rIf you deploy CloudFormation stack, Lambda functions and API Gateway have already been made. You should put required part of these resources.\nMaking Lambda Functions Until last part, we have made AWS services for Full Stack Game. From now on, we are making Lambda functions to handle Game Process.\nIn this lab, we are creating Three Lambda functions.\nLet\u0026rsquo;s make first one.\nMove to Lambda menu on console. https://console.aws.amazon.com/lambda\nClick \u0026ldquo;Create function\u0026rdquo; button and create first function.\nSelect \u0026ldquo;Author from scratch\u0026rdquo;, and create empty function.\nPut game-sqs-process as Name.\nSelect Runtime as Python 3.9.\nIn Permissions tab, choose \u0026ldquo;Use an existing role\u0026rdquo; and select \u0026ldquo;Gomok-game-sqs-process\u0026rdquo;. Execute \u0026ldquo;Create function\u0026rdquo;.\nWhen it is completed, select SQS(Simple Queue Service) as trigger of this function on Designer Group. Than you can create \u0026ldquo;Configure triggers\u0026rdquo; group below.\nCheck SQS queue. It should indicate arn of SQS that has been created before. Basic settings: 128MB Memory and 1 min timeout\nLet\u0026rsquo;s move back to Designer Group. We are making Lambda functions. Please refer \u0026ldquo;GameResultProcessing.py\u0026rdquo; on your source code (Root Folder \u0026gt; Lambda \u0026gt; GameResultProcessing.py). Code: Copy contents of GameResultProcessing.py and Paste code to Lambda function. Change proper region_name for your lab. (ex: ap-northeast-2)\nPlease check Lambda functions Handler. Lambda function can access this handler when it is executed.\nClick \u0026ldquo;Save\u0026rdquo; button to create function. Created function read game result record that is stored in SQS, and update DynamoDB. Lambda function polls SQS queue continously, gets message and updates DynamoDB table. In this lab, we provide Python Package for comfort. For source codes GetRank.py and Scoring.py, please refer Lambda / LambdaDeploy in given Binary Folder. Or you can also import redis module by yourselves. You can find where to download the binary in here.\nSecond Lambda function will be created by uploading Python package. Unlike First function only uses Python standard SDK for its logic, some Lambda functions use External Library like Redis. So, we are using Deploy package for making lambda functions.\nIt will be a good opportunity to make lambda functions with package.\nYou can see two Python files GetRank.py and Scoring.py under Lambda/LambdaDeploy.\nCompress All files on the folder as name \u0026ldquo;LambdaDeploy.zip\u0026rdquo; (Notice: LambdaDeploy should not be included on the zipped file. GetRank.py and Scoring.py should be located root path of the compressed file)\nWe can make Lambda function using this Deploy Package.\nClick \u0026ldquo;Create Function\u0026rdquo; and select \u0026ldquo;Author from scratch\u0026rdquo; to create function.\nSet Name as game-rank-update, and Runtime as Python 3.9, Role as Gomok-game-rank-update. Click Create function button.\nSelect Upload a .ZIP file in Function code Group, and upload LambdaDeploy.zip.\nPut Scoring.handler as Handler, and ElastiCache Endpoint(we made before) for Environment Variables like below. You can manage endpoint safely and efficiently using this Environment Variables without hard-coding.\nFill the environment variable \u0026ldquo;REDIS\u0026rdquo; like follows. Set function Timeout 1 minute.\nSet VPC same as ElastiCache in function configuration. Select all Subnets and Security Group that we made before (GomokuDefault).\nSelect DynamoDB as Triggers on Designer Group above. We are using DynamoDB Table \u0026ldquo;GomokuPlayerInfo\u0026rdquo; as Configuration Trigger of Lambda function. Setting DynamoDB trigger like below. Check \u0026ldquo;Enable Trigger\u0026rdquo; and click Add button. After process is completed, click \u0026ldquo;Save\u0026rdquo; button. For now, it will be failed if you click Test for this function. Last but not least, let\u0026rsquo;s make 3rd Lambda function. It can be made same way.\nCreate Lambda function with \u0026ldquo;Author from scratch\u0026rdquo;.\nPut function name game-rank-reader, Python 3.9 as Runtime, set Gomok-game-rank-reader as Role.\nClick Create function, select \u0026ldquo;Upload a .ZIP file\u0026rdquo; on Actions Menu. Upload LambdaDeploy.zip for this function.\nPut GetRank.handler in Function Code Handler. Make Environment variable as same as before.\nKey : REDIS Value : [ElastiCache Endpoint without port number] Set Timeout 1 minute in Basic settings. Configure VPC as same as VPC that ElastiCache is located. Select all subnets and Security Group that we made previously.\nSave and Complete Lambda function.\nNow we can check Three Lambda functions are made. (If you tried CloudFormation, that there would be Five)\nLambda functions are prepared! Nextly, we are considering how to run these functions. First two functions are triggered by SQS and DynamoDB, but we have not designated trigger for last function.\nWe are using API Gateway for this function. Let\u0026rsquo;s make API Gateway!\nLambda function Test If you finished this page, you are able to test how components that we made work. When SQS takes data, Lambda functions will be triggered. And the function updates data to DynamoDB. Data updated to DynamoDB, triggers another Lambda function by DynamoDB Stream. And this function updates Redis Cache for Ranking Leaderboard.\nWe can test this process simply.\nOpen console to access SQS (https://console.aws.amazon.com/sqs) Select game-result-queue and click Queue Actions button. Click Send Message from drop-down. Put JSON data like below on the text box. { \u0026#34;PlayerName\u0026#34; : \u0026#34;SomeName\u0026#34; , \u0026#34;WinDiff\u0026#34; : 1, \u0026#34;LoseDiff\u0026#34; : 0, \u0026#34;ScoreDiff\u0026#34; : 100 } If it has parse issue, please put text by yourselves Click \u0026ldquo;Send Message\u0026rdquo; You can check Item changed on DynamoDB \u0026ldquo;GomokuPlayerInfo\u0026rdquo; table. If it has an issue, you are able to debug logs from CloudWatch. "
},
{
	"uri": "/aws-gamelift-sample/en/gamelift/lab41/",
	"title": "Making Lambda Functions",
	"tags": [],
	"description": "",
	"content": "\rIf you deploy CloudFormation stack, Lambda functions and API Gateway have already been made. You should put required part of these resources.\nMaking Lambda Functions Until last part, we have made AWS services for Full Stack Game. From now on, we are making Lambda functions to handle Game Process.\nIn this lab, we are creating Three Lambda functions.\nLet\u0026rsquo;s make first one.\nMove to Lambda menu on console. https://console.aws.amazon.com/lambda\nClick \u0026ldquo;Create function\u0026rdquo; button and create first function.\nSelect \u0026ldquo;Author from scratch\u0026rdquo;, and create empty function.\nPut game-sqs-process as Name.\nSelect Runtime as Python 3.9.\nIn Permissions tab, choose \u0026ldquo;Use an existing role\u0026rdquo; and select \u0026ldquo;Gomok-game-sqs-process\u0026rdquo;. Execute \u0026ldquo;Create function\u0026rdquo;.\nWhen it is completed, select SQS(Simple Queue Service) as trigger of this function on Designer Group. Than you can create \u0026ldquo;Configure triggers\u0026rdquo; group below.\nCheck SQS queue. It should indicate arn of SQS that has been created before. Advanced settings: 128MB Memory and 1 min timeout\nLet\u0026rsquo;s move back to Designer Group. We are making Lambda functions. Please refer \u0026ldquo;GameResultProcessing.py\u0026rdquo; on your source code (Root Folder \u0026gt; Lambda \u0026gt; GameResultProcessing.py). Code: Copy contents of GameResultProcessing.py and Paste code to Lambda function. Change proper region_name for your lab. (ex: ap-northeast-2)\nPlease check Lambda functions Handler. Lambda function can access this handler when it is executed.\nClick \u0026ldquo;Save\u0026rdquo; button to create function. Created function read game result record that is stored in SQS, and update DynamoDB. Lambda function polls SQS queue continously, gets message and updates DynamoDB table. In this lab, we provide Python Package for comfort. For source codes GetRank.py and Scoring.py, please refer Lambda / LambdaDeploy.\nSecond Lambda function will be created by uploading Python package. Unlike First function only uses Python standard SDK for its logic, some Lambda functions use External Library like Redis. So, we are using Deploy package for making lambda functions.\nIt will be a good opportunity to make lambda functions with package.\nYou can see two Python files GetRank.py and Scoring.py under Lambda/LambdaDeploy.\nCompress All files on the folder as name \u0026ldquo;LambdaDeploy.zip\u0026rdquo; (Notice: LambdaDeploy should not be included on the zipped file. GetRank.py and Scoring.py should be located root path of the compressed file)\nWe can make Lambda function using this Deploy Package.\nClick \u0026ldquo;Create Function\u0026rdquo; and select \u0026ldquo;Author from scratch\u0026rdquo; to create function.\nSet Name as game-rank-update, and Runtime as Python 3.9, Role as Gomok-game-rank-update. Click Create function button.\nSelect Upload a .ZIP file in Function code Group, and upload LambdaDeploy.zip.\nPut Scoring.handler as Handler, and ElastiCache Endpoint(we made before) for Environment Variables like below. You can manage endpoint safely and efficiently using this Environment Variables without hard-coding.\nSet function Timeout 1 minute.\nSet VPC same as ElastiCache in function configuration. Select all Subnets and Security Group that we made before (GomokuDefault).\nSelect DynamoDB as Triggers on Designer Group above. We are using DynamoDB Table \u0026ldquo;GomokuPlayerInfo\u0026rdquo; as Configuration Trigger of Lambda function. Setting DynamoDB trigger like below. Check \u0026ldquo;Enable Trigger\u0026rdquo; and click Add button. After process is completed, click \u0026ldquo;Save\u0026rdquo; button. For now, it will be failed if you click Test for this function. Last but not least, let\u0026rsquo;s make 3rd Lambda function. It can be made same way.\nCreate Lambda function with \u0026ldquo;Author from scratch\u0026rdquo;.\nPut function name game-rank-reader, Python 3.9 as Runtime, set Gomok-game-rank-reader as Role.\nClick Create function, select \u0026ldquo;Upload a .ZIP file\u0026rdquo; on Code entry type. Upload LambdaDeploy.zip for this function.\nPut GetRank.handler in Function Code Handler. Make Environment variable as same as before.\nKey : REDIS Value : [ElastiCache Endpoint without port number] Set Timeout 1 minute in Basic settings. Configure VPC as same as VPC that ElastiCache is located. Select all subnets and Security Group that we made previously.\nSave and Complete Lambda function.\nNow we can check Three Lambda functions are made. (If you tried CloudFormation, that there would be Five)\nLambda functions are prepared! Nextly, we are considering how to run these functions. First two functions are triggered by SQS and DynamoDB, but we have not designated trigger for last function.\nWe are using API Gateway for this function. Let\u0026rsquo;s make API Gateway!\nLambda function Test If you finished this page, you are able to test how components that we made work. When SQS takes data, Lambda functions will be triggered. And the function updates data to DynamoDB. Data updated to DynamoDB, triggers another Lambda function by DynamoDB Stream. And this function updates Redis Cache for Ranking Leaderboard.\nWe can test this process simply.\nOpen console to access SQS (https://console.aws.amazon.com/sqs) Select game-result-queue and click Queue Actions button. Click Send Message from drop-down. Put JSON data like below on the text box. { \u0026#34;PlayerName\u0026#34; : \u0026#34;SomeName\u0026#34; , \u0026#34;WinDiff\u0026#34; : 1, \u0026#34;LoseDiff\u0026#34; : 0, \u0026#34;ScoreDiff\u0026#34; : 100 } If it has parse issue, please put text by yourselves Click \u0026ldquo;Send Message\u0026rdquo; You can check Item changed on DynamoDB \u0026ldquo;GomokuPlayerInfo\u0026rdquo; table. If it has an issue, you are able to debug logs from CloudWatch. "
},
{
	"uri": "/aws-gamelift-sample/en/intro/lab01/",
	"title": "Workshop Contents",
	"tags": [],
	"description": "",
	"content": "Goal - Make Session based match game using GameLift. - Use GameLift FlexMatch to include Serverless based match system on your game. - Include Advanced functions of FlexMatch, for example using Matchmaking events to make statistics and testing Match Rules. - Start Session based game with Independent FleetIQ for flexibility and cost efficiency.\nHoL Index Part 1 - Make AWS services for making Full Stack Game. (This can be automated easily with CloudFormation) Part 2 - Learn how to adopt FlexMatch features on GameLift. Part 3 - You can start NEW feature \u0026ldquo;FleetIQ\u0026rdquo; for your game servers. Part 4 - It is possible to learn GameLift Classic. Making Matchmaker instance and Gomoku Game. Part 5 - Clean up Game Stack contents.\n"
},
{
	"uri": "/aws-gamelift-sample/en/intro/lab02/",
	"title": "HoL Preparation",
	"tags": [],
	"description": "",
	"content": "Download Binary and Source code You can download source files on the repository below. https://github.com/aws-samples/aws-gamelift-sample\nUse pre-built library for HoL. Binary files are located in \u0026ldquo;bin\u0026rdquo; folder. Also you can download complete binary file from below link. http://d2511y3q5icxx2.cloudfront.net/DemoBinary.zip\nFor more details, You can refer descriptions in each sections.\nInstall AWS CLI It is recommended to install CLI for this Lab. You can install it easily on the next link. https://docs.aws.amazon.com/cli/latest/userguide/install-cliv1.html Install AWS CLI v2 (Option) It is required to install CLI v2 for FleetIQ. In order to try FleetIQ, download CLI v2 via links. Windows : https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-windows.html Mac OS : https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-mac.html Linux : https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-linux.html Windows Configuration Game \u0026ldquo;Gomoku\u0026rdquo; is built on Visual Studio 2015. For your Lab, it is required to install C++ Redistributable Package on Server and Client systems. https://www.microsoft.com/en-us/download/details.aspx?id=48145 "
},
{
	"uri": "/aws-gamelift-sample/en/awsservice/",
	"title": "Build AWS Services",
	"tags": [],
	"description": "",
	"content": "\rIn this Lab, we are making AWS services for user database, game result queue and resource permissions. These AWS services make interesting multiplay game on AWS.\nDeploy CloudFormation Stack To accelerate your GameLift journey, we provide CloudFormation Stack. If you would like to do this lab fastly, you are able to automate resource creation using this link.\nCloudFormation Lab Creating AWS resources using CloudFormation (1-0), you can move on next part immediately.\nCreating AWS Services step by step It is not much difficult to create AWS services for making Full Stack Game. You are able to try by yourselves. This starts from step 1-1.\nMaking DynamoDB Lab for user data Creating ElastiCache Lab Creating SQS for game result handling IAM Policy and Role Creation "
},
{
	"uri": "/aws-gamelift-sample/en/flexmatch/lab22/",
	"title": "Configuring API Gateway",
	"tags": [],
	"description": "",
	"content": "\rIf you deploy CloudFormation stack, Lambda functions and API Gateway have already been made. You should put required part of these resources.\nConfiguring API Gateway We know that one of our Lambda functions requires API Gateway. API Gateway provides endpoint for REST API, HTTP API and WebSocket API. It also has features like API caching, Throttling and operational benefits on API backend.\nIt plays a role of \u0026ldquo;Gateway\u0026rdquo; for Backend Lambda API on this Lab.\nMove API Gateway menu on Console. (https://console.aws.amazon.com/apigateway)\nClick \u0026ldquo;Create API\u0026rdquo;, select REST and set its name \u0026ldquo;GomokuAPI\u0026rdquo;. Endpoint should be Regional.\nCreating API, you can find empty page. Firstly, make Resource and create Method on it. Click \u0026ldquo;Actions\u0026rdquo; button and make Resource.\nPut ranking as Resource Name, and Enable API Gateway CORS. Click \u0026ldquo;Create Resource\u0026rdquo;.\nNext step is creating method. Click \u0026ldquo;Actions\u0026rdquo; button and Create Method. You can see small list box below. Select \u0026ldquo;GET\u0026rdquo; and click check buttons next to it.\nChoose Integration Type Lambda Function, and right region. Select game-rank-reader as Lambda Function. Click Save.\nAPI was made. Now we should deploy this API to production stage. Click \u0026ldquo;Actions\u0026rdquo; and \u0026ldquo;Deploy API\u0026rdquo;.\nSelect [New Stage] and put Stage name \u0026ldquo;prod\u0026rdquo;. Click Deploy button to proceed.\nAfter completion, you can check stage configuration like below. Please check this Invoke URL. We are using this URL as endpoint for S3 static web page. Nextly, we are making static web site built on S3. You can easily host static web site!\n"
},
{
	"uri": "/aws-gamelift-sample/en/gamelift/lab42/",
	"title": "Configuring API Gateway",
	"tags": [],
	"description": "",
	"content": "\rIf you deploy CloudFormation stack, Lambda functions and API Gateway have already been made. You should put required part of these resources.\nConfiguring API Gateway We know that one of our Lambda functions requires API Gateway. API Gateway provides endpoint for REST API, HTTP API and WebSocket API. It also has features like API caching, Throttling and operational benefits on API backend.\nIt plays a role of \u0026ldquo;Gateway\u0026rdquo; for Backend Lambda API on this Lab.\nMove API Gateway menu on Console. (https://console.aws.amazon.com/apigateway)\nClick \u0026ldquo;Create API\u0026rdquo;, select REST and set its name \u0026ldquo;GomokuAPI\u0026rdquo;. Endpoint should be Regional.\nCreating API, you can find empty page. Firstly, make Resource and create Method on it. Click \u0026ldquo;Actions\u0026rdquo; button and make Resource.\nPut ranking as Resource Name, and Enable API Gateway CORS. Click \u0026ldquo;Create Resource\u0026rdquo;.\nNext step is creating method. Click \u0026ldquo;Actions\u0026rdquo; button and Create Method. You can see small list box below. Select \u0026ldquo;GET\u0026rdquo; and click check buttons next to it.\nChoose Integration Type Lambda Function, and right region. Select game-rank-reader as Lambda Function. Click Save.\nAPI was made. Now we should deploy this API to production stage. Click \u0026ldquo;Actions\u0026rdquo; and \u0026ldquo;Deploy API\u0026rdquo;.\nSelect [New Stage] and put Stage name \u0026ldquo;prod\u0026rdquo;. Click Deploy button to proceed.\nAfter completion, you can check stage configuration like below. Please check this Invoke URL. We are using this URL as endpoint for S3 static web page. Nextly, we are making static web site built on S3. You can easily host static web site!\n"
},
{
	"uri": "/aws-gamelift-sample/en/awsservice/lab12/",
	"title": "ElastiCache Configuration",
	"tags": [],
	"description": "",
	"content": "ElastiCache Configuration Nextly, we will configure ElastiCache. This cache will store ranking data.\nMove to ElastiCache Console on your AWS Console. https://console.aws.amazon.com/elasticache Create ElastiCache cluster. We are using Redis. Select Redis Cluster from the left menu and click Create Redis Cluster. Fill the information like below. Name: gomokuranking Engine: 6.2 (5.0.4 above recommended) Port: 6379 (default) Parameter group: default Number of replicas: 0 In subnet group setting, you can select an existing default vpc and subnet or create a new vpc and subnet group for workshop.\nClick \u0026ldquo;Create\u0026rdquo; button to create \u0026ldquo;Redis\u0026rdquo;. (It takes time to create Redis)\nWhen Redis cluster turns it\u0026rsquo;s status \u0026ldquo;Available\u0026rdquo;, check Primary Endpoint. We use this endpoint on our Lambda functions.\nNextly, make Security Group for this ElastiCache. We are making very simple Security Group for our resources.\nLet\u0026rsquo;s move to VPC console(https://console.aws.amazon.com/vpc). Click \u0026ldquo;Security Group\u0026rdquo; menu on left side tab and create Security Group.\nPut right information on Name tag, Group name, etc and Select default VPC.\nWe should fix inbound policy in this security group. Select Security Group and Click Inbound Rules.\nClick \u0026ldquo;Edit\u0026rdquo; button, and create inbound policy like below. Put Security Group ID itself as source. In this policy, it is able to communicate between resources that have this security group.\nType: All traffic Protocol: All Source: Security Group itself After you finish creating Security Group, move to ElastiCache Console. Select Redis that we made.\nClick \u0026ldquo;Modify\u0026rdquo; on the above, Modify Security Group settings to apply Security Group that we created before\nNow we finish ElastiCache configurations, next page is for SQS.\n"
},
{
	"uri": "/aws-gamelift-sample/en/intro/lab03/",
	"title": "Service Information",
	"tags": [],
	"description": "",
	"content": "\rLab contains various AWS Services to make Full Stack Game Service. This part guides some of services used on this lab.\nGameLift Amazon GameLift is managed AWS Service for Session based multiplayer games. GameLift provides high performance and high reliability with cost efficiency. GameLift serves managed hosting for Session based game, Realtime game, and independent FleetIQ features. https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-intro.html DynamoDB Amazon DynamoDB is managed NoSQL database on AWS with high performance, scalability and reliability. DynamoDB can be used efficiently on Serverless Architecture, and this database can handle high traffics on distributed environment. In this lab, DynamoDB is used to store user data. https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html ElastiCache Amazon ElastiCache is managed In-memory database compatible with Redis and Memcached. In this lab, we are using for storing ranking data. https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/WhatIs.html SQS Amazon SQS provides high durability queue for system. It is able to use decouple on distributed systems with this queue for flexibility. Game processes result with SQS queue. https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/welcome.html Lambda AWS Lambda is serverless compute service that runs code without provisioning or managing servers. We are going to use Lambda functions as API backend. https://docs.aws.amazon.com/lambda/latest/dg/welcome.html API Gateway Amazon API Gateway provides API endpoints for REST API and WebSocket API, and serves various features. In this lab, we are using Lambda functions with API Gateway. https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html S3 Amazon S3 is Object Storage that we can use via Internet. It is used for Static Web Hosting in this lab. https://docs.aws.amazon.com/AmazonS3/latest/dev/Welcome.html "
},
{
	"uri": "/aws-gamelift-sample/en/flexmatch/",
	"title": "GameLift FlexMatch Lab",
	"tags": [],
	"description": "",
	"content": "Making Game Server with GameLift Service In this HoL, FlexMatch uses Serverless Matchmaking for flexible Architecture. This content is different from that of GameLift Classic Lab.\nArchitecture Diagram (FlexMatch) This Architecture is for FlexMatch Lab.\nInternal Logic of FlexMatch is different from classical Architecture of GameLift. With GameLift FlexMatch, you are able to use various features with flexible design.\nNext architecture describes how this application will work in detail.\nIn FlexMatch Lab, you are using Serverless Matchmaking with Lambda. And no need to provisioned Matchmaker Server. You can use Matchmaking as per requests efficiently.\nLab Index 1. Lambda functions 2. API Gateway configuration 3. S3 Web hosting 4. Game Server Build and Fleet 5. Serverless based FlexMatch and Lambda API 6. FlexMatch Game Client (Game Play!) 7. FlexMatch Matchmaking Events 8. FlexMatch Ruleset Test\n"
},
{
	"uri": "/aws-gamelift-sample/en/awsservice/lab13/",
	"title": "Making SQS",
	"tags": [],
	"description": "",
	"content": "Making SQS Let\u0026rsquo;s make SQS configuration! We are using SQS queue for processing Game Result.\nAccess to SQS menu on Console. https://console.aws.amazon.com/sqs Click \u0026ldquo;Create Queue\u0026rdquo; button. Put queue name as \u0026ldquo;game-result-queue\u0026rdquo;, and select Standard Queue. Click \u0026ldquo;Create Queue\u0026rdquo; button and finish creation. When queue creation is completed, check endpoint URL on its details. We are using this URL next part. We can check actions with Queue, DynamoDB, and ElastiCache on next part with Lambda functions.\n"
},
{
	"uri": "/aws-gamelift-sample/en/fleetiq/lab31/",
	"title": "Preparations",
	"tags": [],
	"description": "",
	"content": "\rYou can start this lab with minimal dependencies. But it is one of the newest features, so we need CLI v2.\nInstalling CLIv2 It is required to install CLI v2 for FleetIQ. In order to try FleetIQ, download CLI v2 via links. Windows : https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-windows.html Mac OS : https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-mac.html Linux : https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2-linux.html Cloud9 IDE AWS Cloud9 is a cloud-based integrated development environment (IDE) that lets you write, run, and debug your code with just a browser. In this lab, we are making codes with Cloud9. It is recommended to use Cloud9 in order to make development environment simply. "
},
{
	"uri": "/aws-gamelift-sample/en/flexmatch/lab23/",
	"title": "S3 Web Hosting",
	"tags": [],
	"description": "",
	"content": "Leaderboard with S3 Web Hosting Previously we made database, API to handle user data and game result with API Gateway and Lambda function. In this page, we are going to make static web site that S3 host. We can make Ranking board easily with this static web page with Lambda function that we made before.\nMove to S3 service and create S3 bucket for web site. Creating bucket, uncheck Block all public access to allow public object. There is web directory in the given source code. You can find main.js in this folder. Open main.js from Text editor.\nEdit API Endpoint in source code. Modify URL to Invoke URL of API Gateway that we made previously.\nSave modified main.js and upload all files in web directory to the S3 bucket that we made.\nGive Public read access permission to objects.\nClick Properties tab in bucket. Enable Static website hosting on this bucket.\nPut index.html on Index document and click \u0026ldquo;Save\u0026rdquo; button.\nWhen your files are uploaded, you are able to check web page on Static website hosting endpoint.\nYou should configure CORS on API Gateway. You can check Ranking board data from web page by this endpoint.\nMove back to API Gateway, click \u0026ldquo;Actions\u0026rdquo; button and enable CORS option. (If it is disabled)\nConfiguring CORS. Set Access-Control-Allow-Origin to your static website URL. (In this HoL, it is OK to configure * for your comfort)\nClick \u0026ldquo;Enable CORS\u0026rdquo; button.\nIf it is completed, you are able to find OPTIONS in your resource tab.\nClick \u0026ldquo;Deploy API\u0026rdquo; button to deploy it prod stage.\nYou are able to check its data from API endpoint or this web page.\nWeb page made on this section will be used for ranking leaderboard like below.\nNow, it is time to make Game Server! :)\n"
},
{
	"uri": "/aws-gamelift-sample/en/gamelift/lab43/",
	"title": "S3 Web Hosting",
	"tags": [],
	"description": "",
	"content": "Leaderboard with S3 Web Hosting Previously we made database, API to handle user data and game result with API Gateway and Lambda function. In this page, we are going to make static web site that S3 host. We can make Ranking board easily with this static web page with Lambda function that we made before.\nMove to S3 service and create S3 bucket for web site. Creating bucket, uncheck Block all public access to allow public object. There is web directory in the given source code. You can find main.js in this folder. Open main.js from Text editor.\nEdit API Endpoint in source code. Modify URL to Invoke URL of API Gateway that we made previously.\nSave modified main.js and upload all files in web directory to the S3 bucket that we made.\nGive Public read access permission to objects.\nClick Properties tab in bucket. Enable Static website hosting on this bucket.\nPut index.html on Index document and click \u0026ldquo;Save\u0026rdquo; button.\nWhen your files are uploaded, you are able to check web page on Static website hosting endpoint.\nYou should configure CORS on API Gateway. You can check Ranking board data from web page by this endpoint.\nMove back to API Gateway, click \u0026ldquo;Actions\u0026rdquo; button and enable CORS option. (If it is disabled)\nConfiguring CORS. Set Access-Control-Allow-Origin to your static website URL. (In this HoL, it is OK to configure * for your comfort)\nClick \u0026ldquo;Enable CORS\u0026rdquo; button.\nIf it is completed, you are able to find OPTIONS in your resource tab.\nClick \u0026ldquo;Deploy API\u0026rdquo; button to deploy it prod stage.\nYou are able to check its data from API endpoint or this web page.\nWeb page made on this section will be used for ranking leaderboard like below.\nNow, it is time to make Game Server! :)\n"
},
{
	"uri": "/aws-gamelift-sample/en/flexmatch/lab24/",
	"title": "Creating Game Server Build &amp; Fleet",
	"tags": [],
	"description": "",
	"content": "Creating Game Server with GameLift Service In this page, we are making GameLift Service with Serverless based FlexMatch server binary. We provide Game Server as compiled binary, therefore you don\u0026rsquo;t need to build by yourselves. But if you want, you are able to compile and build binary by yourselves. For more detail, you can refer Appendix for information.\nDeveloping FlexMatch features on Game Server or Client, it is possible to use Matchmaking without provisioning individual servers for Matchmaker. For this lab, you can use FlexMatch binary on bin/FlexMatch/GomokuServer.\nPrepare compiled binary. It should be provided for this lab. However if you want to customize or debug, you can refer how to build source codes on Appendix.\nCheck whether there are files GomokuServer.exe, aws-cpp-sdk-*.dll, config.ini, install.bat, aws-cpp-sdk-gamelift-server.dll exist on given folder bin/GomokuServer.\nIt is required to install vc_redist.x86.exe for window servers in this workshop. Please place vc_redist.x86.exe files from This Link. You can also download Full version of deployment file from This Link\nEdit config.ini using Text Editor. SQS_REGION means region that made Game Result SQS queue(ex : ap-northeast-1). Also, put SQS_ENDPOINT values of SQS endpoint URL.\nFor ROLE_ARN, you should insert IAM Role ARN for GameLift Fleet that we made last of part 1. (It is also possible to get Role ARN from Instance. In this lab, pass value through config.ini for comfort)\nTo upload Game Server Build on GameLift Service, we should use CLI. If you do not have CLI on your environment, please install referring HoL Preparation.\nUpload build using GameLift CLI on the folder \u0026ldquo;GomokuServer\u0026rdquo; like below. (Please check GomokuServer directory contains Binaries folder and install.bat)\naws gamelift upload-build --name \u0026#34;GomokuServer-Build-1\u0026#34; --build-version \u0026#34;1.0.0\u0026#34; --build-root . --region \u0026lt;Your Lab Region\u0026gt; Check whether region is configured well.\nIt is possible to see its progress when you access GameLift console. (https://console.aws.amazon.com/gamelift)\nClick build that has uploaded just before. You are able to click \u0026ldquo;Create fleet from build\u0026rdquo; button. Clicking this button, create Game Server Fleet.\nPut information below. Other information can be configured as default. Name: GomokuGameServerFleet-1 Instance Type: C5.large Fleet type: Spot Instance Role ARN: IAM Role ARN for GameLift Fleet that we made last page of part 1 (Gomoku-GameLiftFleetRole) Process Management (Check Green button)\nLaunch path: Binaries\\Win64\\GomokuServer.exe (If you compiled by yourselves, put path of your binary) Concurrency Process : 50 Network Configuration (Check Green button)\nEC2 Port Setting : 49152-60000 Protocol : TCP IP address range : 0.0.0.0/0 You can focus Fleet Type \u0026ldquo;SPOT\u0026rdquo; on this setting. It is able to use your Game Server Instances cost-efficient by using Spot Fleet.\nCreating Server Fleet, it changes its status to \u0026ldquo;Active\u0026rdquo;, and its color to green. It takes around 20 minutes. Picture above is built from another version and used to help understanding, it can be different from your lab environment.\nLet\u0026rsquo;s create Alias until Fleet is launched.\nClick \u0026ldquo;Create Alias\u0026rdquo; on the menu. And make input for Alias name and Description.\nChoose \u0026ldquo;Simple\u0026rdquo; for Routing options Type and click \u0026ldquo;Select Fleet\u0026rdquo; on Associated Fleet. Choose Fleet made right before.\nIt is possible to choose the fleet, even though it has not yet been made. When Alias is called, requests will pass to associated Fleet.\nWe are using Alias ID, on Actual use case of GameLift Fleet. Save Alias ID when Alias is made. If there are no actions, the number of Fleet automatically scales-in to 0. In this lab, this would not be an issue, but if you would like to run server fleet longer, then you need to set scale parameter minimum 1. Or you can also override run instance more than 1. "
},
{
	"uri": "/aws-gamelift-sample/en/gamelift/lab44/",
	"title": "Creating Game Server Build &amp; Fleet",
	"tags": [],
	"description": "",
	"content": "Creating Game Server with GameLift Service We will now begin configuring the server binaries to work with the Gamelift service.\nPrepare compiled binary. It should be provided for this lab. However if you want to customize or debug, you can refer how to build source codes on Appendix.\nCheck whether there are files GomokuServer.exe, aws-cpp-sdk-*.dll, config.ini, install.bat, aws-cpp-sdk-gamelift-server.dll exist on given folder bin/GomokuServer. Check whether vc_redist.x86.exe exists.\nEdit config.ini file using Text editor. SQS_REGION means Region that SQS has been created. (ex: ap-northeast-2). Put SQS endpoint for SQS_ENDPOINT. In SQS_ACCESSKEY and SQS_SECRETKEY, write IAM User Access Key and Secret Access Key.\nThe binaries in this lab were created before the IAM role was supported, and for the convenience of the lab, Credential is delivered. Currently, there is no need to pass the Credential directly, the best practice is to use the IAM Role. You can refer to the related information through the FlexMatch lab. Please do not expose your credentials in real use cases.\nIf you are working on a file in a Mac or Windows environment and distributing it on an independent system, be aware of the text file format. In particular, the New Line format in Windows differs by CRLF, which may affect parsing of settings.\nBuild GameLift Binary using CLI. If CLI environment is not configured, please refer Preparation. Since the path of the build and the path of the executable file (exe) in the GameLift console to be set must match, it is recommended to execute the command in the path including the GomokuServer.exe. aws gamelift upload-build --name \u0026#34;Classic_Build-1\u0026#34; --build-version \u0026#34;0.0.1\u0026#34; --build-root . --region us-east-1 When uploading, make sure you set the lab region correctly.\nYou are able to find build is uploading when you move to GameLift console. https://console.aws.amazon.com/gamelift\nWhen the build is successful, it is activated as shown above. Let\u0026rsquo;s create a Fleet from a successful build. Enter the settings as follows. If you select Spot Type from Fleet Type, you can configure GameLift instance fleets in the form of spot fleets. GameLift chooses the fleet with the lowest interruption rate and cost by placing the Spot instance on the instance type with the lowest interruption probability. With this feature, we can use GameLift service cost-efficiently.\nName: GomokuGameServerFleet-1 Instance type: c3.large or c4.large Launch path: GomokuServer.exe Concurrent processes: 50 EC2 Port settings Port range: 49152-60000 Protocol: TCP IP address range: 0.0.0.0/0 When setup is completed, create a fleet clicking \u0026ldquo;Initialize Fleet\u0026rdquo; button. The operation takes about 20 minutes.\nWhen fleet making is completed, it changes to the above state. Let\u0026rsquo;s configure Alias ​​while the fleet is being created.\nOpen the GameLift menu and click on the \u0026ldquo;Create Alias\u0026rdquo; ​​menu. Specify an appropriate alias and select the routing type as Simple. Associate creating Fleet at the Alias. We are using Alias to access Fleet. Record Alias ID. Let\u0026rsquo;s make Matchmaking server next.\n"
},
{
	"uri": "/aws-gamelift-sample/en/awsservice/lab14/",
	"title": "Creating IAM Policy and Role",
	"tags": [],
	"description": "",
	"content": "Creating IAM Policy and Role As last of this part, we are creating IAM Policy and Role for Full Stack Application.\nFirstly, making Policy for Role. In this lab, we are using AWS Managed Policy for comfort. Move to IAM menu on console. https://console.aws.amazon.com/iam\nSelect Policies on menu, and click Create Policy button.\nSelect GameLift on Visual Editor \u0026gt; Service. For Actions, we are selecting \u0026ldquo;All GameLift actions\u0026rdquo; for comfort. Click \u0026ldquo;Review Policy\u0026rdquo;.\nPut Policy Name(GameLiftFullAccess) and Click \u0026ldquo;Create policy\u0026rdquo; Button.\nNexly, we are creating five IAM Roles for Lambda functions.\nMove IAM Console \u0026gt; Role menu, and click \u0026ldquo;Create Role\u0026rdquo; button.\nSelect AWS Lambda for Role Type.\nAllocate 3 IAM policies on this Role. Select Policies (AmazonSQSFullAccess, AmazonDynamoDBFullAccess, AWSLambdaBasicExecutionRole) on the editor.\nPut Tag as an option, and Click Next:Review. Role Name would be \u0026ldquo;Gomok-game-sqs-process\u0026rdquo;.\nClick \u0026ldquo;Create role\u0026rdquo; button to create first IAM Role.\nCreating second role is also similar. For this role, choose AmazonDynamoDBFullAcess, AmazonVPCFullAccess, AWSLambdaBasicExecutionRole as Permission.\nDesignate Role name as \u0026ldquo;Gomok-game-rank-update\u0026rdquo;.\nThird role is also similar. Let\u0026rsquo;s set AmazonVPCFullAccess, AWSLambdaBasicExecutionRole policies for this Role.\nSet role\u0026rsquo;s name as \u0026ldquo;Gomok-game-rank-reader\u0026rdquo;.\nCreating fourth role uses Policy that we made above(GameLiftFullAccess). Let\u0026rsquo;s put permissions AWSLambdaBasicExecutionRole, AmazonDynamoDBFullAccess, and GameLiftFullAccess for this Role.\nSet its name as \u0026ldquo;Gomok-game-match-request\u0026rdquo;.\nLast Role will also be same. It should contain AWSLambdaBasicExecutionRole, GameLiftFullAccess Policies as permissions.\nName of last role would be \u0026ldquo;Gomok-game-match-status\u0026rdquo;\nCreating all IAM Roles, you can find roles below!\nLastly, make additional Role for GameLift. Roles that we made before were used for Lambda functions, but this role is for GameLift Fleet. GameLift Fleet needs to access SQS for Game Result Processing.\nClick \u0026ldquo;Create Role\u0026rdquo; and make new Role. We should select \u0026ldquo;GameLift\u0026rdquo; as Service, but for now select \u0026ldquo;EC2\u0026rdquo; as service, and move next.\nSelect AmazonSQSFullAccess as Permission, and set role name as \u0026ldquo;Gomoku-GameLiftFleetRole\u0026rdquo;.\nWe should change service that uses this Role to GameLift. Select \u0026ldquo;Gomoku-GameLiftFleetRole\u0026rdquo; on console, and select \u0026ldquo;Trust relationships\u0026rdquo; tab. Click \u0026ldquo;Edit trust relationship\u0026rdquo; button.\nChange settings like below. It will be changed \u0026ldquo;ec2 -\u0026gt; gamelift\u0026rdquo;. Save with \u0026ldquo;Update Trust Policy\u0026rdquo; button.\nThis is all about first part on this lab. :) No so complicated. right?\nLet\u0026rsquo;s make Game server on next part.\n"
},
{
	"uri": "/aws-gamelift-sample/en/fleetiq/lab32/",
	"title": "Setting Fiesta IAM",
	"tags": [],
	"description": "",
	"content": "Setting IAM for using Fiesta To use independent FleetIQ, it is needed to make restricted permissions for EC2 instances and Auto Scaling.\nLogin to IAM console. (https://console.aws.amazon.com/iam)\nClick \u0026ldquo;Create Policy\u0026rdquo; on IAM policy menu.\nCreate policy and put JSON schema for it.\nPolicy document is configured like below. You can paste this code.\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;ec2:TerminateInstances\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;ec2:ResourceTag/GameLift\u0026#34;: \u0026#34;GameServerGroups\u0026#34; } } }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;autoscaling:CompleteLifecycleAction\u0026#34;, \u0026#34;autoscaling:ResumeProcesses\u0026#34;, \u0026#34;autoscaling:EnterStandby\u0026#34;, \u0026#34;autoscaling:SetInstanceProtection\u0026#34;, \u0026#34;autoscaling:UpdateAutoScalingGroup\u0026#34;, \u0026#34;autoscaling:SuspendProcesses\u0026#34;, \u0026#34;autoscaling:DetachInstances\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;aws:ResourceTag/GameLift\u0026#34;: \u0026#34;GameServerGroups\u0026#34; } } }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;ec2:DescribeImages\u0026#34;, \u0026#34;ec2:DescribeInstances\u0026#34;, \u0026#34;autoscaling:DescribeAutoScalingGroups\u0026#34;, \u0026#34;ec2:DescribeLaunchTemplateVersions\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;sns:Publish\u0026#34;, \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:sns:*:*:ActivatingLifecycleHookTopic-*\u0026#34;, \u0026#34;arn:aws:sns:*:*:TerminatingLifecycleHookTopic-*\u0026#34; ] } ] } Set the name of policy as FleetIQFiestaPolicy. Let\u0026rsquo;s make IAM role to use this policy. Create Role with EC2 use case like below. Attach FleetIQFiestaPolicy that we made right before to permission policies. We should edit its trusted relationship. It is configured to ec2 for trusted entity. Edit trusted relationship like below. { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: [ \u0026#34;gamelift.amazonaws.com\u0026#34;, \u0026#34;autoscaling.amazonaws.com\u0026#34; ] }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } Policy document described above means GameLift and Auto Scaling can assume this role. When you finish to make IAM policy and Role for Fiesta, let\u0026rsquo;s move on configuration for server instances for FleetIQ. "
},
{
	"uri": "/aws-gamelift-sample/en/fleetiq/",
	"title": "Start with FleetIQ",
	"tags": [],
	"description": "",
	"content": "Start Independent FleetIQ features on your Game. Previously, we made session game server instances using GameLift. GameLift provided us Spot fleet for our game server instances. With this \u0026ldquo;SPOT fleet\u0026rdquo;, you are able to save 60-80% costs for the instances. And GameLift feature named \u0026ldquo;FleetIQ\u0026rdquo; suggested the most reliable instances for SPOT instances against Spot Interruption. So, that is the reason why we are able to use GameLift with cost-efficienty and reliability.\nThis feature \u0026ldquo;FleetIQ\u0026rdquo; is now supported independently. Now we can manage EC2 instances and Auto Scaling Group by ourselves and make flexible architecture using SPOT instances. Therefore, we can have cost-efficient, more reliable and flexible architecture for our game server!\nIn this part, Let\u0026rsquo;s try how to start FleetIQ easily. Independent FleetIQ feature is currently provided as Preview, so this material will be updated continously.\nArchitecture Diagram Although FleetIQ feature is included in GameLift, it has independent architecture.\nGame server and client can be implemented using FleetIQ supported SDK, CLI or API. It uses independent from GameLift, so it does not depend on GameLift lifecycle.\nLet\u0026rsquo;s take a look how it works!\nFor more details about FleetIQ, you can refer link below.\nhttps://docs.aws.amazon.com/ko_kr/gamelift/latest/developerguide/gsg-intro.html\n"
},
{
	"uri": "/aws-gamelift-sample/en/flexmatch/lab25/",
	"title": "Build Serverless FlexMatch",
	"tags": [],
	"description": "",
	"content": "How to build Serverless FlexMatch In this Lab, we are starting FlexMatch Matchmaking based on Serverless Architecture.\nWith FlexMatch, you can implement session based matchmaker easily without provisioning servers for it. To use FlexMatch, you need to call FlexMatch API or SDK on game server or game client side. In this Lab, we are using Lambda. This approach can allow cost-efficient serverless model on your game server backend.\nConfiguring GameLift Queue We are going to use GameLift Queue for matchmaking.\nClick \u0026ldquo;Create a queue\u0026rdquo; on GameLift Console. Put the name on queue like below. And choose Alias that we made before on destination. Click \u0026ldquo;Create queue\u0026rdquo; to make. Nextly, we are making rule for FlexMatch. Click \u0026ldquo;Create matchmaking rule set\u0026rdquo; button.\nSet rule set name as you want, and put rule set policy below on \u0026ldquo;Rule set box\u0026rdquo;. Rule set is provided from GomokuRuleSet.json under the rootFolder/Ruleset directory on a given source code. Copy the code and paste it to console box.\n{ \u0026#34;ruleLanguageVersion\u0026#34; : \u0026#34;1.0\u0026#34;, \u0026#34;playerAttributes\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;score\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;number\u0026#34;, \u0026#34;default\u0026#34; : 1000 } ], \u0026#34;teams\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;blue\u0026#34;, \u0026#34;maxPlayers\u0026#34; : 1, \u0026#34;minPlayers\u0026#34; : 1 }, { \u0026#34;name\u0026#34; : \u0026#34;red\u0026#34;, \u0026#34;maxPlayers\u0026#34; : 1, \u0026#34;minPlayers\u0026#34; : 1 } ], \u0026#34;rules\u0026#34; : [ { \u0026#34;name\u0026#34;: \u0026#34;EqualTeamSizes\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;comparison\u0026#34;, \u0026#34;measurements\u0026#34;: [ \u0026#34;count(teams[red].players)\u0026#34; ], \u0026#34;referenceValue\u0026#34;: \u0026#34;count(teams[blue].players)\u0026#34;, \u0026#34;operation\u0026#34;: \u0026#34;=\u0026#34; }, { \u0026#34;name\u0026#34; : \u0026#34;FairTeamSkill\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;distance\u0026#34;, \u0026#34;measurements\u0026#34; : [ \u0026#34;avg(teams[*].players.attributes[score])\u0026#34; ], \u0026#34;referenceValue\u0026#34; : \u0026#34;avg(flatten(teams[*].players.attributes[score]))\u0026#34;, \u0026#34;maxDistance\u0026#34; : 300 } ], \u0026#34;expansions\u0026#34; : [ { \u0026#34;target\u0026#34; : \u0026#34;rules[FairTeamSkill].maxDistance\u0026#34;, \u0026#34;steps\u0026#34; : [ { \u0026#34;waitTimeSeconds\u0026#34; : 10, \u0026#34;value\u0026#34; : 500 }, { \u0026#34;waitTimeSeconds\u0026#34; : 20, \u0026#34;value\u0026#34; : 800 }, { \u0026#34;waitTimeSeconds\u0026#34; : 30, \u0026#34;value\u0026#34; : 1000 } ] } ] } This rule matches players that have score differences under 300, and if match cannot be accepted in time, mitigate matchmaking rule and find players! Click \u0026ldquo;Validate rule set\u0026rdquo;, and check rule set is fine. And click \u0026ldquo;Create rule set\u0026rdquo;.\nNext thing to do is linking GameLift Queue and Matchmaking rule set. Click \u0026ldquo;Create matchmaking configuration\u0026rdquo; on the menu. Select queue and rule set like below, and create configuration. Please check you choose right region and queue. Creating Lambda function If you deploy CloudFormation stack, Lambda functions have already been made. You should just put required part of these resources.\nGameLift FlexMatch configuration was completed! Next step is building Lambda function and API Gateway that game client makes request for FlexMatch. In this lab, we are going to make two Lambda functions. First one is handling matchmaking requests from client, second one is checking matchmaking results. Let\u0026rsquo;s make first Lambda function. It will not be difficult!\nMove to Lambda Console. https://console.aws.amazon.com/lambda\nClick \u0026ldquo;Create function\u0026rdquo; button.\nCheck \u0026ldquo;Author from scratch\u0026rdquo;.\nPut the Name of the function \u0026ldquo;game-match-request\u0026rdquo;.\nChoose Python 3.9 as Runtime.\nChoose Role on Permissions Tab. Check \u0026ldquo;Use an existing role\u0026rdquo; and select \u0026ldquo;Gomok-game-match-request\u0026rdquo; as IAM Role. Click \u0026ldquo;Create function\u0026rdquo; button.\nFind Lambda/MatchRequest.py at your source code. Copy the contents and paste it to Console. Check Region and Match Configuration is configured correctly. Sample Image is just for reference. This can be different from your Lab environment. Also please check Handler and function name is same. Set Basic settings on your function. Memory : 128MB Timeout : 1 min Click \u0026ldquo;Save\u0026rdquo; button and make function. This function receives Matchmaking requests from game client, reads user data from DynamoDB and send Matchmaking requests to GameLift.\nClick \u0026ldquo;Create function\u0026rdquo; button and let\u0026rsquo;s make second function.\nCheck \u0026ldquo;Author from scratch\u0026rdquo; and start with empty function.\nPut \u0026ldquo;game-match-status\u0026rdquo; as Name, and select Python 3.9 as Runtime.\nChoose Role on Permissions Tab. Check \u0026ldquo;Use an existing role\u0026rdquo; and select \u0026ldquo;Gomok-game-match-status\u0026rdquo; as IAM Role. Click \u0026ldquo;Create function\u0026rdquo; button.\nFind Lambda/MatchStatus.py at your source code. Copy source code and paste it to Lambda Code textbox.\nLike above, set Basic settings on your function. Memory : 128MB Timeout : 1 min Please check Lambda functions Handler. Lambda function can access this handler when it is executed.\nClick \u0026ldquo;Save\u0026rdquo; button and make function. This function check matchmaking request is done by using TicketId that game clients sent, and send Game server\u0026rsquo;s IP address and Port information to game client as response. API Gateway Configuration Let\u0026rsquo;s make API for these Lambda functions.\nMove to API Gateway console. (https://console.aws.amazon.com/apigateway)\nChoose API Gateway that is already made, and click \u0026ldquo;Create Resource\u0026rdquo; button.\nWrite Resource name matchrequest on the box. Check \u0026ldquo;Enable API Gateway CORS\u0026rdquo; and click \u0026ldquo;Create Resource\u0026rdquo; button. Create new method for this resource. Click \u0026ldquo;Actions\u0026rdquo; button and \u0026ldquo;Create Method\u0026rdquo;. Make API for \u0026ldquo;POST\u0026rdquo; method.\nSelect Integration type with Lambda function, and check correct region. Choose game-match-request for Lambda function and click \u0026ldquo;Save\u0026rdquo; button.\nMake second API for second Lambda function. Click \u0026ldquo;Actions\u0026rdquo; on the root path and \u0026ldquo;Create Resource\u0026rdquo;.\nCreate API as we had. Resource Name will be matchstatus and enable API Gateway CORS.\nMaking POST method, and integrate with game-match-status Lambda function. Click \u0026ldquo;Save\u0026rdquo; button.\nNow we finish to make APIs for Lambda functions. Let\u0026rsquo;s deploy this API. Click \u0026ldquo;Actions\u0026rdquo; button and \u0026ldquo;Deploy API\u0026rdquo;.\nAfter you deploy your API, you can find Invoke URL. This URL will be used for game client. "
},
{
	"uri": "/aws-gamelift-sample/en/fleetiq/lab33/",
	"title": "Creating Game Server Group",
	"tags": [],
	"description": "",
	"content": "FleetIQ makes abstraction layer Game Server Group for game hosting, and it uses Auto Scaling Group. Game server resources are registered in FleetIQ, and managed in Game Server Group.\nWhen you create a game server group in FleetIQ, an Auto Scaling Group is created, and computing resources to allocate within the Auto Scaling Group are launched. So it\u0026rsquo;s important to allocate a group of game servers with appropriate instance types to optimize your computing resources. FleetIQ regularly evaluates each Spot instance types in the game server group list based on the prediction algorithm to calculate the feasibility for hosting the game.\nMaking IAM Role for FleetIQ Instances Move to IAM console. (https://console.aws.amazon.com/iam/home?)\nClick \u0026ldquo;Role\u0026rdquo; button on IAM console, and create new Role for EC2 use case.\nAttach Permissions policies. If you search \u0026ldquo;GameLift\u0026rdquo; as a keyword, you are able to find GameLiftGameServerGroupPolicy. Also if we finish previous lab, you can find GameLiftFullAccess Role. (If not, please refer 1-4 on this lab)\nSelect two policies, make Role, and set its name GameLiftFleetIQRole. Creating EC2 Launch Template Access to EC2 console (https://console.aws.amazon.com/ec2/v2/home)\nClick Start Template in the left menu and create a new start template.\nConfigure the template as follows.\nIf you have conducted Windows-based labs before, in this lab, we will configure a Linux-based game server, so choose Amazon Linux2 AMI. This can show you how your architecture can be flexible. The key-pair setting is also performed to enable login.\nCreate a LaunchTemplate in your default VPC. Make sure to configure the VPC settings and security groups accordingly. There are no restrictions, but since the server and the client are going to communicate via TCP, the Security Group is configured to allow proper inbound configuration for the TCP protocol. Choose GameLiftFleetIQRole that we made previously for IAM instance Profile.\nPut follow text as user data.\n#!/bin/bash sudo yum install python3 -y sudo pip3 install boto3 sudo pip3 install requests sudo yum install -y gcc-c++ make curl -sL https://rpm.nodesource.com/setup_12.x | sudo -E bash sudo yum install -y nodejs The user data code above describes the operation to connect the Cloud9 IDE remotely when the game server is created.\nCreating Game Server Group Let\u0026rsquo;s make Game Server Group. You are able to try this with AWS CLI v2.\nPut command as follows. aws gamelift create-game-server-group --game-server-group-name GameServerGroups --role-arn \u0026lt;FleetIQFiestaRole ARN\u0026gt; --min-size 1 --max-size 2 --launch-template LaunchTemplateId=\u0026lt;LaunchTemplate ID\u0026gt; --instance-definitions \u0026#39;[{\u0026#34;InstanceType\u0026#34;: \u0026#34;c5.large\u0026#34;}, {\u0026#34;InstanceType\u0026#34;: \u0026#34;m5.large\u0026#34;}]\u0026#39; --region ap-northeast-2 Please put right information between brackets \u0026lt;\u0026gt;. Also check for region on this command.\nWhen you finish \u0026ldquo;CreateServerGroup\u0026rdquo;, you are able to see Game Server Group that you made on GameLift Console as follows. If the creation of the game server group is too delayed, it is recommended to check the permissions.\nYou can check Auto Scaling Group configurations. You can also check the auto-created instance in the EC2 console. Those indicate game servers available in the game server group.\nHowever, you can\u0026rsquo;t use FleetIQ function through the game servers yet. To use FleetIQ function, you must configure FleetIQ Lifecycle.\n"
},
{
	"uri": "/aws-gamelift-sample/en/gamelift/lab45/",
	"title": "Creating Matchmaker Server",
	"tags": [],
	"description": "",
	"content": "Create server instance for Matchmaking The content of this section is different from the case of using FlexMatch. FlexMatch uses its own matchmaking provided by GameLift, without making your own matchmaker. If you want to practice using FlexMatch, you can try Lab 2.\nIf a game server is being deployed on Fleet that will handle real game sessions and run logic, you need a matchmaker to properly establish a TCP connection to that server.\nIn general, a session-based game is implemented in such a way that the server for matchmaking is handled by a separate instance, and the server distributes the session to the game server.\nIn this Lab, you are able to use Matchmaker server binary(Matchmaker.exe) or build GomokuMatchMaker project on Visual Studio by yourselves.\nModify config.ini included with executable matchmaker(.exe). Specify the Alias ​​created earlier as above, and configure the port settings and service region appropriately. Configure the DynamoDB table name that contains user information also.\nNext, you need to create an IAM Role for the EC2 server where the matchmaker will be configured. Creating EC2 IAM Role, and grant access control policies for DynamoDB and GameLift.\nConfigure the EC2 server to act as a matchmaker. Configure an instance based on Windows 2016. This binary was written and tested on 2016 basis. Assign a security group that allows the port specified in config.ini (default 5999). That policy should be allowed for TCP traffic. Give the instance the IAM Role created in the above step. Access to the instance, copy Matchmaker binary. Launching vc_redist_x64.exe for the first time, configure C++ runtime environment.\nOnce the environment is configured, run GomokuMatchMaker.exe to run Matchmaker.\nFinally, assign an Elastic IP (EIP) address and give it to your instance so that you can contact the Matchmaker server. GomokuClient will connect to the matchmaker server with that IP address!\n"
},
{
	"uri": "/aws-gamelift-sample/en/gamelift/",
	"title": "GameLift Classic Lab (Option)",
	"tags": [],
	"description": "",
	"content": "\rThis Lab will implement \u0026ldquo;Gomoku\u0026rdquo; game using purely GameLift function regardless of FlexMatch or FleetIQ. If the FlexMatch feature is not yet available in some regions, this lab can be useful for getting started with GameLift.\nLab Index 1. Making Lambda functions for processing Game Result. 2. Creating API Gateway for ranking board. 3. Making S3 based static web hosting. 4. Create Game Server Build and Fleet. 5. Create EC2 instance for Matchmaking. 6. Configuring Game Client and connect Session Game Server\nArchitecture Diagram The difference from the FlexMatch based architecture is that it configures independent instances for matchmaking. We will focus on this part and practice. There is no significant difference in the rest of the process.\n"
},
{
	"uri": "/aws-gamelift-sample/en/cleanup/",
	"title": "Clean Up",
	"tags": [],
	"description": "",
	"content": "\rCongratulations! It is time to clean up your resources.\nCloudFormation Clean Up If you allocate resources using CloudFormation, it is able to remove resources deleting CloudFormation stack.\nClick \u0026ldquo;Delete\u0026rdquo; button on CloudFormation console.\nAt this time, if there is a dependency on the resource created during the lab, you must either remove the dependency or manually remove the resource.\nDeleting Resources Remove those resources on your console.\nGameLift Build, Fleet and Alias. GameLift Queue, Matchmaking configuration. EC2 instance for Matchmaker. DynamoDB, ElastiCache, S3. Lambda functions. API Gateway. Resources used for FleetIQ. Remove FleetIQ Resources To remove resources from FleetIQ, execute the following command in the location where the CLIv2 environment is installed.\naws gamelift delete-game-server-group --game-server-group-name \u0026lt;Game Server Group Name\u0026gt; "
},
{
	"uri": "/aws-gamelift-sample/en/flexmatch/lab26/",
	"title": "Configuring Matchmaking Event",
	"tags": [],
	"description": "",
	"content": "Configuring FlexMatch Matchmaking Event In this lab, we are going to make a matchmaking event handler triggered by GameLift. Matchmaking event notification is a key feature of FlexMatch. It is able to track match making results quickly and flexibly.\nMove to the Amazon SNS Console. (https://console.aws.amazon.com/sns/v3/home)\nClick \u0026ldquo;Topic\u0026rdquo; on the left menu. Click \u0026ldquo;Create Topic\u0026rdquo; button to create new Topic.\nSet topic type to Standard. Make topic with name \u0026ldquo;gomoku-match-topic\u0026rdquo;.\nModify the Access Policy below. Clicking the Advanced radio button, and put the JSON as below. This policy allows Amazon GameLift access to the SNS topic.\n{ \u0026#34;Version\u0026#34;: \u0026#34;2008-10-17\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;__default_policy_ID\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;__default_statement_ID\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;AWS\u0026#34;: \u0026#34;*\u0026#34; }, \u0026#34;Action\u0026#34;: [ \u0026#34;SNS:GetTopicAttributes\u0026#34;, \u0026#34;SNS:SetTopicAttributes\u0026#34;, \u0026#34;SNS:AddPermission\u0026#34;, \u0026#34;SNS:RemovePermission\u0026#34;, \u0026#34;SNS:DeleteTopic\u0026#34;, \u0026#34;SNS:Subscribe\u0026#34;, \u0026#34;SNS:ListSubscriptionsByTopic\u0026#34;, \u0026#34;SNS:Publish\u0026#34;, \u0026#34;SNS:Receive\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:sns:{your_region}:{your_account}:{your_topic_name}\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;AWS:SourceOwner\u0026#34;: \u0026#34;{your_account}\u0026#34; } } }, { \u0026#34;Sid\u0026#34;: \u0026#34;__console_pub_0\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;gamelift.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;SNS:Publish\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:sns:{your_region}:{your_account}:{your_topic_name}\u0026#34; } ] } In the above policy, enter the relevant region, account information, and the topic name (gomoku-match-topic) in the part marked with {} in the above policy. Account information is displayed as a numeric array on the right side of MyAccount by clicking the login ID in the upper right corner of the console.\nClick \u0026ldquo;Create Topic\u0026rdquo; button. Next, create a Lambda function to handle the event. This function subscribes to the Amazon SNS topic created above and stores the connection information in the previously created DynamoDB.\nMove to the AWS Lambda console. (https://console.aws.amazon.com/lambda/home)\nClick the Create Function button to start creating a new Lambda function with the following settings:\nFunction Name : game-match-event Runtime : Python 3.9 Permissions \u0026gt; Execution Role : Create a new role from AWS policy templates Permissions \u0026gt; Role name : BasicLambdaDynamoDBRole Permissions \u0026gt; Policy templates \u0026gt; Simple microservice permissions When the function is created, click \u0026ldquo;Add Trigger\u0026rdquo; button on the left side, and select Amazon SNS. Choose SNS Topic created above (gomoku-match-topic). This function subscribes the Topic and is triggered with the given event. Change the code as follows(Refer codes from MatchEvent.py) : import boto3 import json import time import datetime dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;, region_name=\u0026#39;us-east-1\u0026#39;) ddb_table = dynamodb.Table(\u0026#39;GomokuPlayerInfo\u0026#39;) def lambda_handler(event, context): print(event) sns_message = json.loads(event[\u0026#39;Records\u0026#39;][0][\u0026#39;Sns\u0026#39;][\u0026#39;Message\u0026#39;]) matchevent_status = sns_message[\u0026#39;detail\u0026#39;][\u0026#39;type\u0026#39;] if matchevent_status == \u0026#39;MatchmakingSucceeded\u0026#39;: gamesession_info = sns_message[\u0026#39;detail\u0026#39;][\u0026#39;gameSessionInfo\u0026#39;] address = gamesession_info[\u0026#39;ipAddress\u0026#39;] port = int(gamesession_info[\u0026#39;port\u0026#39;]) players = gamesession_info[\u0026#39;players\u0026#39;] for player in players: player_id = player[\u0026#39;playerId\u0026#39;] if \u0026#39;playerSessionId\u0026#39; in player: player_session_id = player[\u0026#39;playerSessionId\u0026#39;] connection_info = { \u0026#39;IpAddress\u0026#39;: address, \u0026#39;Port\u0026#39;: port, \u0026#39;PlayerSessionId\u0026#39;: player_session_id, \u0026#39;timestamp\u0026#39;: int(time.time()), \u0026#39;status\u0026#39;: \u0026#39;matching\u0026#39; } ddb_table.update_item( TableName=\u0026#34;GomokuPlayerInfo\u0026#34;, Key={ \u0026#39;PlayerName\u0026#39; : player_id }, UpdateExpression=\u0026#34;set ConnectionInfo = :connection_info\u0026#34;, ExpressionAttributeValues={ \u0026#39;:connection_info\u0026#39;: \u0026#34;\u0026#34; + json.dumps(connection_info), }, ReturnValues=\u0026#34;UPDATED_NEW\u0026#34; ) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Hello from Lambda!\u0026#39;) } The function code stores matchmaking information from events triggered by Amazon SNS to DynamoDB.\nNext, let\u0026rsquo;s configure GameLift to publish events to the SNS topic.\nMove to the Amazon GameLift console. (https://console.aws.amazon.com/gamelift/home)\nChoose Matchmaking Configuration. Select the GomokuMatchConfig setting you made previously.\nEditing the configuration by clicking Actions \u0026gt; Edit Matchmaking Configuration button.\nPut SNS Topic\u0026rsquo;s Arn created above at the Notification Target as follows :\nMatches configured in GameLift are now pushed directly to social media topics. The Lambda function that drives the topic receives it and updates the connection information in DynamoDB.\n"
},
{
	"uri": "/aws-gamelift-sample/en/fleetiq/lab34/",
	"title": "Creating Server on FleetIQ",
	"tags": [],
	"description": "",
	"content": "Making FleetIQ Server development environment FleetIQ Server - Client model is not depend on GameLift. Currently, implementation is provided in the form of CLI and SDK, and in this lab, we will implement Python-based TCP communication. It\u0026rsquo;s a simple, and good example of understanding how FleetIQ works and creating a server-client structure.\nAccess to Cloud9 console. (https://console.aws.amazon.com/cloud9/home)\nCreate new IDE as follows. We are making code with this IDE.\nSet the connection configuration to SSH, and connect the endpoint of the game server instance in the game server group that you have just created. At this time, you need to copy and connect the SSH key at the bottom. If you copy SSH key, connect to the instance on EC2 console as follows. You can use EC2 Instance Connect for this action. Click the instance and find \u0026ldquo;Connect\u0026rdquo; button on console. Or you are able to connect via SSH or PuTTY. For more details, you can find more information on This Link.\nvi ~/.ssh/authorized_keys Put command above, and append copied text to the end of this file.\nssh-rsa ~~~ key ssh-rsa @@@ xxx@amazon.com Then the file seems like above.\nFor easy configuration, typing A as the vi reference moves to the end of the file. After hitting the Enter key, paste and save.\nEnter the following script in the server instance\u0026rsquo;s console: curl -L https://raw.githubusercontent.com/c9/install/master/install.sh | bash Cloud9 is easily installed on your EC2 instance via the above script.\nGo back to the Cloud9 console and complete the configuration. The IDE should be configured as follows. Writing Server side script Create Python script named server.py. Copy the following server script and paste it to the file. We will modify this code one by one. import socket import boto3 import requests GameServerGroupName = \u0026#39;GameServerGroups\u0026#39; GameServerId = \u0026#39;game-server-1\u0026#39; InstanceId = requests.get(\u0026#39;http://169.254.169.254/latest/meta-data/instance-id\u0026#39;).text ConnectionInfo = requests.get(\u0026#39;http://169.254.169.254/latest/meta-data/public-hostname\u0026#39;).text client = boto3.client(\u0026#39;gamelift\u0026#39;, \u0026#39;ap-northeast-2\u0026#39;) server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.bind((\u0026#34;\u0026#34;, 5000)) server_socket.listen(5) def list_game_servers(): pass # Register GameServer def register_game_server(): pass # # Update GameServer def update_game_server(flag): pass # # Deregister GameServer def deregister_game_server(): pass # print(\u0026#34;TCP server waiting for Client on port 5000\u0026#34;) while True: # List Game Server listResponse = list_game_servers() if not \u0026#39;GameServers\u0026#39; in listResponse or not any(server[\u0026#39;GameServerId\u0026#39;] == GameServerId for server in listResponse[\u0026#39;GameServers\u0026#39;]): # Register Game Server to Game Server Group register_game_server() # # Update Game Server Status \u0026#34;AVAILABLE\u0026#34; update_game_server(True) # client_socket, address = server_socket.accept() print(\u0026#34;I got connection from \u0026#34;, address) # Update Game Server Status \u0026#34;UTILIZED\u0026#34; update_game_server(False) # while True: data = client_socket.recv(512).decode() print(\u0026#34;RECEIVED:\u0026#34;, data) if(data == \u0026#39;q\u0026#39; or data == \u0026#39;Q\u0026#39;): client_socket.close() break else: client_socket.send(data.encode()) # Deregister Game Server deregister_game_server() # server_socket.close() print(\u0026#34;SOCKET Closed... End\u0026#34;) First, in the code above, change the region to the region where you are practicing. Then, change the top GameServerGroupName to the game server group name you configured earlier. GameServerId should be uniquely specified in Game Server Group.\nFill in the contents of each empty function code. First, the list_game_servers function. def list_game_servers(): response = client.list_game_servers( GameServerGroupName=GameServerGroupName ) print(response) return response This function checks the game servers in the game server group currently available. If it is empty, you need to register a new one.\nNext, register the game server. The following code demonstrates registering an instance of the game server itself with a server group. def register_game_server(): response = client.register_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId, InstanceId=InstanceId, ConnectionInfo=ConnectionInfo ) print(response) The update_game_server function reports whether the server itself is currently available. It can also play a role of FleetIQ\u0026rsquo;s health check process. def update_game_server(flag): if flag == True: return client.update_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId, HealthCheck=\u0026#34;HEALTHY\u0026#34;, UtilizationStatus=\u0026#34;AVAILABLE\u0026#34; ) else: return client.update_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId, HealthCheck=\u0026#34;HEALTHY\u0026#34;, UtilizationStatus=\u0026#34;UTILIZED\u0026#34; ) The deregister_game_server function is a function that unregisters a game server. In this example, since it is a server that handles a single client, it is released after the loop and re-registered on the next connection, but the actual implementation adjusts the game server\u0026rsquo;s lifecycle according to the client handling logic. def deregister_game_server(): response = client.deregister_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId ) print(response) Completed codes look like as follows. import socket import boto3 import requests GameServerGroupName = \u0026#39;GameServerGroups\u0026#39; GameServerId = \u0026#39;game-server-1\u0026#39; InstanceId = requests.get(\u0026#39;http://169.254.169.254/latest/meta-data/instance-id\u0026#39;).text ConnectionInfo = requests.get(\u0026#39;http://169.254.169.254/latest/meta-data/public-hostname\u0026#39;).text client = boto3.client(\u0026#39;gamelift\u0026#39;, \u0026#39;ap-northeast-2\u0026#39;) server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.bind((\u0026#34;\u0026#34;, 5000)) server_socket.listen(5) def list_game_servers(): response = client.list_game_servers( GameServerGroupName=GameServerGroupName ) print(response) return response # Register GameServer def register_game_server(): response = client.register_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId, InstanceId=InstanceId, ConnectionInfo=ConnectionInfo ) print(response) # # Update GameServer def update_game_server(flag): if flag == True: return client.update_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId, HealthCheck=\u0026#34;HEALTHY\u0026#34;, UtilizationStatus=\u0026#34;AVAILABLE\u0026#34; ) else: return client.update_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId, HealthCheck=\u0026#34;HEALTHY\u0026#34;, UtilizationStatus=\u0026#34;UTILIZED\u0026#34; ) # # Deregister GameServer def deregister_game_server(): response = client.deregister_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId ) print(response) # print(\u0026#34;TCP server waiting for Client on port 5000\u0026#34;) while True: # List Game Server listResponse = list_game_servers() if not \u0026#39;GameServers\u0026#39; in listResponse or not any(server[\u0026#39;GameServerId\u0026#39;] == GameServerId for server in listResponse[\u0026#39;GameServers\u0026#39;]): # Register Game Server to Game Server Group register_game_server() # # Update Game Server Status \u0026#34;AVAILABLE\u0026#34; update_game_server(True) # client_socket, address = server_socket.accept() print(\u0026#34;I got connection from \u0026#34;, address) # Update Game Server Status \u0026#34;UTILIZED\u0026#34; update_game_server(False) # while True: data = client_socket.recv(512).decode() print(\u0026#34;RECEIVED:\u0026#34;, data) if(data == \u0026#39;q\u0026#39; or data == \u0026#39;Q\u0026#39;): client_socket.close() break else: client_socket.send(data.encode()) # Deregister Game Server deregister_game_server() # server_socket.close() print(\u0026#34;SOCKET Closed... End\u0026#34;) Next, let\u0026rsquo;s implement the client. "
},
{
	"uri": "/aws-gamelift-sample/en/gamelift/lab46/",
	"title": "Game Client Settings &amp; Game Play!",
	"tags": [],
	"description": "",
	"content": "Game Client Settings \u0026amp; Game Play! The content of this section is different from the case of using FlexMatch. Note that the FlexMatch version of the client binaries is different from the binaries in this lab. If you want to practice using FlexMatch, you can try Part 2.\nIn the previous exercise, we deployed a game server to handle sessions through the GameLift service, and we configured a match server environment to match sessions with GameLift\u0026rsquo;s fleet deployed through the matchmaker server.\nIt is time to play Gomoku! Wow.. it must be so exciting..!\nFor practice, use a game client binary(Classic/client/GomokuClient.exe), or directly build the GomokuClient project in the root folder in Visual Studio. If you build your own binaries, we recommend building in 64-bit Release mode.\nModify the config.ini file in the root directory of the GomokuClient project. Set the EIP of the matchmaker server created in the previous chapter, and set the port to connect to. Since the client does not support a separate login function, enter the user information to log in to the configuration file.\nIf you don\u0026rsquo;t have an account, you will be a new member, but please be aware that if the login information does not match, you will not be able to play the game!\nLaunch GomokuClient.exe. To play the game Click the right button and press Game Start button. When you start the game, it searches for matching opponents.\nOnce matched, you can enjoy the game! Beat your opponent and become the winner of the Gomoku!\nThe game results are stored in the database and this can be checked through the S3 website endpoint that you configured earlier. "
},
{
	"uri": "/aws-gamelift-sample/en/appendix/",
	"title": "Appendix",
	"tags": [],
	"description": "",
	"content": "Build GameLift Binary Game Server and Game Client were developed and built based on Visual Studio 2015. We recommend you to build source code compatible to the environment.\nChoose GomokuClient or GomokuServer from given source codes.\nOpen project on Visual Studio or compatible IDE. Projects have dependencies based on Nuget Package, and also for DLL Dependencies for AWS SDK.\nSet project like below, and build.\nWe recommend you to set \u0026ldquo;Release\u0026rdquo; as build environment. Release folders have already included related dependencies. You can also debug your project with including dependencies.\nGameLift Classic Project and GameLift FlexMatch Project depend on different version of SDK. So those have different functions on their implementations.\nConnect to GameLift Game Server GameLift manage game server resources, but we need to access game server for some reasons such as debugging or accessing logs. If you need to access game server, you can follow this guide below.\nYou need to use CLI for commands.\nGetting instance list from FleetID of the fleet with this command. aws gamelift describe-instances --fleet-id fleet-4b7fc542-cb08-4f65-908c-737f64ca2e8f --region ap-northeast-2 We could get instance-id of the instance that we want to access. Therefore we can use this command below using FleetId and InstanceId. aws gamelift get-instance-access --fleet-id fleet-4b7fc542-cb08-4f65-908c-737f64ca2e8f --instance-id i-031278fb03cf29d35 --region ap-northeast-2 Above command gives you the information to access. Access the instance via RDP or SSH. If game server fleet do not authorize to access port, you can configure it in console. Picture above describes configuration that allows RDP port for the instance. You can configure your fleet as needed.\n"
},
{
	"uri": "/aws-gamelift-sample/en/flexmatch/lab27/",
	"title": "Connecting Game Client with FlexMatch",
	"tags": [],
	"description": "",
	"content": "Connecting Game Client with FlexMatch To use FlexMatch, game server or client should be modified to use FlexMatch functions. In this Lab, we make game client send requests to Lambda functions that we made previously, and Lambda functions match game sessions with FlexMatch functions.\nWe are using Gomoku Client on Windows OS.\nOur game client makes two Outbound TCP connections. So, please check if you need to configure your firewall.\nFind Game Client on bin/FlexMatch/Client_player1 in given binary files.\nWe need to modify config.ini at this client.\nPut API Gateway URL that we made previously on MATCH_SERVER_API.\nSave with PLAYER_NAME and PLAYER_PASSWD. If player does not exist, game server registers new user. But if given password is wrong, login fails.\nRun Game Client(GomokuClient.exe) on your system. It will work like picture below.\nGomoku should be played with others! Open config.ini at bin/FlexMatch/Client_player2 and modify the config.\nLaunch secondary Game Client, and start playing!\nYou can give up when it is impossible to win.\nTest Matchmaking with changing DynamoDB scores.\nCongratulations! This is all for GameLift and FlexMatch Lab.\nAfter this part, you are able to try FlexMatch Advanced features and GameLift FleetIQ. :)\n"
},
{
	"uri": "/aws-gamelift-sample/en/fleetiq/lab35/",
	"title": "Creating Client on FleetIQ",
	"tags": [],
	"description": "",
	"content": "Create Development Environment based on Cloud9 In this lab, we will use Cloud9, a Cloud-based IDE, to easily build a remote development environment and create a client for the FleetIQ example.\nWith Cloud9, you can build a consistent online integrated development environment without any changes to the local environment or difficulty in configuring the development environment.\nAccess to Cloud9 console. (https://ap-northeast-2.console.aws.amazon.com/cloud9/home/product)\nSet name as FleetIQClient\nSpecify it as an EC2 environment and choose the appropriate instance type. Network settings are configured to be located in the default VPC. Wait for creation of Cloud9. It will take few minutes.\nWhen Cloud9 IDE is executed, create file client.py and paste following code.\nimport socket import boto3 client = boto3.client(\u0026#39;gamelift\u0026#39;) # Claim Game Server def claim_game_server(): pass # response = claim_game_server() #endpoint = response[\u0026#39;GameServer\u0026#39;][\u0026#39;ConnectionInfo\u0026#39;] endpoint = \u0026#39;\u0026#39; client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client_socket.connect((endpoint, 5000)) while True: data = input(\u0026#34;SEND(TYPE q or Q to Quit):\u0026#34;) if(data == \u0026#39;q\u0026#39; or data == \u0026#39;Q\u0026#39;): client_socket.send(data.encode()) client_socket.close() break else: client_socket.send(data.encode()) data = client_socket.recv(512).decode() print(\u0026#34;RECEIVED:\u0026#34;, data) print(\u0026#34;Socket Closed... END\u0026#34;) This code is a simple TCP echo client implementation. However, if you look closely, the server\u0026rsquo;s endpoint is not specified. Now let\u0026rsquo;s implement this part.\nYou must implement the claim_game_server function in your code. The claimGameServer API is an API that requests GameLift FleetIQ for a server instance suitable for allocating game sessions to clients. The client only needs to make a request through the corresponding API to connect to the game server. Let\u0026rsquo;s make a code on claim_game_server as follows. def claim_game_server(): response = client.claim_game_server( GameServerGroupName=\u0026#39;GameServerGroups\u0026#39; ) print(response) return response Function\u0026rsquo;s return value contains Game Server endpoint. Remove comment and set endpoint like below.\nendpoint = response[\u0026#39;GameServer\u0026#39;][\u0026#39;ConnectionInfo\u0026#39;] The complete code is: import socket import boto3 client = boto3.client(\u0026#39;gamelift\u0026#39;, \u0026#39;ap-northeast-2\u0026#39;) # Claim Game Server def claim_game_server(): response = client.claim_game_server( GameServerGroupName=\u0026#39;GameServerGroups\u0026#39; ) print(response) return response # response = claim_game_server() endpoint = response[\u0026#39;GameServer\u0026#39;][\u0026#39;ConnectionInfo\u0026#39;] client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client_socket.connect((endpoint, 5000)) while True: data = input(\u0026#34;SEND(TYPE q or Q to Quit):\u0026#34;) if(data == \u0026#39;q\u0026#39; or data == \u0026#39;Q\u0026#39;): client_socket.send(data.encode()) client_socket.close() break else: client_socket.send(data.encode()) data = client_socket.recv(512).decode() print(\u0026#34;RECEIVED:\u0026#34;, data) print(\u0026#34;Socket Closed... END\u0026#34;) In the lab, only a simple TCP connection is configured for the purpose of learning to run the FleetIQ API, but the code is simple, but you can practice with more complex game logic.\nNow let\u0026rsquo;s see how the server and client interact with the one we created earlier.\n"
},
{
	"uri": "/aws-gamelift-sample/en/flexmatch/lab28/",
	"title": "Analyzing Matchmaking Event",
	"tags": [],
	"description": "",
	"content": "Analyzing FlexMatch Matchmaking Event When you make Game, executing itself will not be your goal. Operation and management are very important for Game Service. FlexMatch provides Matchmaking Events, and it makes events related to GameLift tickets.\nWith Matchmaking events, we are able to use this features for checking issue status, match status monitoring or troubleshooting and debugging.\nIn this page, we are looking how to log Matchmaking events and analyze game session match patterns easily with FlexMatch Matchmaking events and CloudWatch Logs.\nCloudWatch Logs is nice tool for monitoring Log streams near-realtime, ans we can make monitoring system by Logs Insight without provisioning any resources. So, it would be good opportunity to practice!\nCreating Lambda function to handle FlexMatch Matchmaking events. Select Author from scratch. You don\u0026rsquo;t need to change Permission settings for your comfort.\nSet function name as game-flexmatch-event, and Runtime would be Python 3.9. Permission requires permission to record logs in CloudWatch Logs, and can be easily implemented with basic Lambda permission.\nFunction code is not provided, but you can use this source code below. :) If it is possible, I recommend you to modify this source code! Let\u0026rsquo;s check how Matchmaking can be handled and what kinds of information can we get!\nimport json def lambda_handler(event, context): eventType = event[\u0026#39;detail\u0026#39;][\u0026#39;type\u0026#39;] if (eventType == \u0026#34;MatchmakingSucceeded\u0026#34;): a = event[\u0026#39;detail\u0026#39;][\u0026#39;gameSessionInfo\u0026#39;][\u0026#39;players\u0026#39;][0][\u0026#39;playerId\u0026#39;] b = event[\u0026#39;detail\u0026#39;][\u0026#39;gameSessionInfo\u0026#39;][\u0026#39;players\u0026#39;][1][\u0026#39;playerId\u0026#39;] print(\u0026#34;Matchmaking: \u0026#34; + a + \u0026#34;,\u0026#34; + b) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Hello from Lambda!\u0026#39;) } This code inspects Matchmaking event ticket types and write logs for Matchmaking data. Logs printed in Lambda function send its output stream to CloudWatch Logs as default.\nAccess to CloudWatch Console in order to make trigger. (https://console.aws.amazon.com/cloudwatch)\nClick \u0026ldquo;CloudWatch Events\u0026rdquo; on the left side of the console. Click \u0026ldquo;Get Started\u0026rdquo; or \u0026ldquo;Create Rule\u0026rdquo;.\nLet\u0026rsquo;s create Rule like below. We could also configure various Targets such as SNS topic, but we are using Lambda functions(game-flexmatch-event) as Target.\nSet proper name for event and click \u0026ldquo;Create\u0026rdquo; button. Check Rule was successfully created. Let\u0026rsquo;s play \u0026ldquo;Gomoku\u0026rdquo; game again! We can check CloudWatch Logs that CloudWatch Events logs events from Lambda functions. We also find Matchmaking events on logs. It contains Matchmaking lists on its logs. Click \u0026ldquo;Logs Insight\u0026rdquo; on left side of menu.\nNext queries provide Matchmaking results from log data as raw data filtering.\nfields @timestamp, @message | filter @message like /Matchmaking:/ | sort @timestamp desc | limit 20 You are able to put this query inside of textbox in Logs Insight\nThe result can be different from picture above. Next queries provide statistics information that is aggregated recent Matchmaking results. stats count(*) by @message | filter @message like /Matchmaking:/ | sort @timestamp desc | limit 20 And result can be like below.\nWe have tested simple example this page. You can play more games, and make more queries for your game easily. This kind of features will make you balance game session matching on early stage of your games. "
},
{
	"uri": "/aws-gamelift-sample/en/fleetiq/lab36/",
	"title": "Connect Server and Client",
	"tags": [],
	"description": "",
	"content": "Making FleetIQ based Server - Client Connection Move to Cloud9 IDE on the server instance.\nRun script with Python 3 as follows.\nWhen the server is running, it will wait for the client to connect. Next, go to the client Cloud9 IDE to launch the client.\nRun the client script in the same way. The echo client will run as follows! Now check the TCP socket communication with the server.\nIt is noteworthy that the session connection was configured with an efficient instance based on the Fiesta algorithm by receiving connection information from the FleetIQ service. Now you can flexibly and cost-effectively build session-based gaming services with standalone FleetIQ capabilities. Congratulation! This is all for this FleetIQ lab. You can also refer more on This link\n"
},
{
	"uri": "/aws-gamelift-sample/en/flexmatch/lab29/",
	"title": "Test FlexMatch Ruleset",
	"tags": [],
	"description": "",
	"content": "Test FlexMatch Ruleset There are some rulesets for you to test. Excellent Matchmaking enough to facinate users very well! We provide some examples for you, and we hope these rulesets can help you to inspire making your ruleset.\nIn this page, we are testing how can apply new rule to your game easily.\nLet\u0026rsquo;s make Matchmaking Ruleset for new Ruleset.\nYou can test rulesets below.\nAnd move to Matchmaking configurations. There would be configuration that made previously. You can edit matchmaking configuration like below. You can change ruleset that you made above.\nBasic Ruleset : For basic ruleset, it has already applied on current game. Please refer page 2-5.\nStrict Ruleset : Some games need strict types of Matchmaking. For example, games like tournament require ratings evaluated by Win or Lose should match opponents strictly.\n{ \u0026#34;name\u0026#34;: \u0026#34;Strict Matching\u0026#34;, \u0026#34;ruleLanguageVersion\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;playerAttributes\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;score\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;number\u0026#34;, \u0026#34;default\u0026#34; : 1000 } ], \u0026#34;teams\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;player\u0026#34;, \u0026#34;minPlayers\u0026#34;: 1, \u0026#34;maxPlayers\u0026#34;: 1, \u0026#34;quantity\u0026#34;: 2 }], \u0026#34;rules\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;SameScore\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Only match players when they have same score\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;comparison\u0026#34;, \u0026#34;operation\u0026#34;: \u0026#34;=\u0026#34;, \u0026#34;measurements\u0026#34;: [\u0026#34;flatten(teams[*].players.attributes[score])\u0026#34;] }] } Fast Match Ruleset : There are some types of games which is very important for players to match other players. If you would like to consider making global games, it can also be important. Most of users want to play games quickly with low latency. { \u0026#34;name\u0026#34;: \u0026#34;Fast Game\u0026#34;, \u0026#34;ruleLanguageVersion\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;playerAttributes\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;score\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;number\u0026#34;, \u0026#34;default\u0026#34; : 1000 } ], \u0026#34;teams\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;blue\u0026#34;, \u0026#34;maxPlayers\u0026#34; : 1, \u0026#34;minPlayers\u0026#34; : 1 }, { \u0026#34;name\u0026#34; : \u0026#34;red\u0026#34;, \u0026#34;maxPlayers\u0026#34; : 1, \u0026#34;minPlayers\u0026#34; : 1 } ], \u0026#34;rules\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;FastConnection\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Prefer matches with fast player connections first\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;latency\u0026#34;, \u0026#34;maxLatency\u0026#34;: 50 }], \u0026#34;expansions\u0026#34;: [{ \u0026#34;target\u0026#34;: \u0026#34;rules[FastConnection].maxLatency\u0026#34;, \u0026#34;steps\u0026#34;: [{ \u0026#34;waitTimeSeconds\u0026#34;: 10, \u0026#34;value\u0026#34;: 100 }, { \u0026#34;waitTimeSeconds\u0026#34;: 20, \u0026#34;value\u0026#34;: 150 }] }] } Except for these examples above, you can make your own ruleset for the games. Please refer below link, and test it. https://docs.aws.amazon.com/gamelift/latest/developerguide/match-rulesets.html\n"
},
{
	"uri": "/aws-gamelift-sample/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/aws-gamelift-sample/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]