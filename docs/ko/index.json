[
{
	"uri": "/aws-gamelift-sample/ko/awsservice/lab10/",
	"title": "CloudFormation 스택 생성",
	"tags": [],
	"description": "",
	"content": "CloudFormation 을 통한 스택 생성 자동화 이번 장에서는 앞선 AWS 서비스 구성 단계들을 CloudFormation 을 이용해서 간소화된 스택으로 구성합니다. 이번 단계는 직접 서비스들을 구성하는 단계에서의 실수를 줄이고, 보다 빠르게 GameLift 를 이용한 실습을 하고자할 경우에 적합합니다. 이번 단계에서 서비스들을 배포하셨다면, 1장의 나머지 단계는 건너뛰셔도 좋습니다.\n실습 환경을 갖추고자 하는 리전의 CloudFormation 콘솔로 접속합니다. (https://ap-northeast-2.console.aws.amazon.com/cloudformation)\n다운로드받은 소스 파일에서 CloudFormation 폴더에 \u0026ldquo;GomokuHoLTemplate.json\u0026rdquo; 항목을 찾습니다.\nCloudFormation 콘솔에서 \u0026ldquo;스택 생성 항목을 누른 뒤, 템플릿 지정 \u0026gt; 템플릿 파일 업로드를 선택합니다. GomokuHoLTemplate.json 파일을 업로드합니다.\n디자이너로 보면 다음과 같은 CloudFormation 스택을 확인하실 수 있습니다. 다양한 리소스 스택에 대해 다음과 같이 자동화된 스택 구성이 가능합니다. s 5. 스택 이름을 GameLiftHoL 로 입력합니다.\n절차에 따라 스택을 생성합니다. 다음과 같이 모든 리소스가 정상적으로 배포되는지 확인합니다. 동일한 리소스가 이미 리전에 존재하는 경우 리소스가 만들어지지 않을 수 있습니다. 만약, 동일한 리소스가 존재한다면 만들어진 리소스들을 지우고 다시 시도합니다. 이 장의 실습을 마치셨다면 다음 장 실습으로 이동합니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/",
	"title": "GameLift HoL",
	"tags": [],
	"description": "",
	"content": "GameLift 로 시작하는 Full Stack Game 지난 수개월간 만들어온 여러분의 게임이 드디어 완성을 앞두고 있습니다. \u0026ldquo;오목\u0026rdquo; 은 가로 세로 19칸으로 그어진 선 위에서 우주만물의 음과 양을 상징하는 검은 돌과 흰 돌을 사용하는 게임입니다. 두 명의 플레이어는 그들의 검은 돌과 흰 돌을 각각 격자에 놓게 되고, 처음으로 5개의 돌을 직선(혹은 대각선)으로 만든 플레이어가 승리하게 됩니다.\n하지만 게임은 만들었는데, 생각치 못한 점을 발견하게 됩니다. 이럴수가\u0026hellip; 오목은 혼자 할 수는 없다는 것이었죠! 여러분은 몇가지 AWS 서비스를 통해 \u0026ldquo;인터넷\u0026rdquo; 을 통한 플레이를 제공하기로 설정했습니다. 힘들 것 같나요? 하지만 이번 데모에서 게임은 이미 준비되어 있습니다.\n한가지만 명심하면 됩니다. 여러분에게는 큰 운영(Ops) 조직이 없기 때문에 Serverless 및 관리형 서비스를 활용하여 최대한 효율적이고 최적화된 방식을 활용해서 만들어야 합니다. 즉, API Gateway, Lambda, ElastiCache(Redis), S3, DynamoDB, SQS 그리고 GameLift 를 사용해서 Full Stack 을 만들어보겠습니다!\n오늘의 데모 오늘 우리가 만들 게임입니다 :) 정말 재미있겠군요! 멀티플레이 게임을 만드는 것은 복잡하다고 느낄 수 있지만 순서대로 따라하시다보면 어렵지 않습니다!\n"
},
{
	"uri": "/aws-gamelift-sample/ko/awsservice/lab11/",
	"title": "DynamoDB 만들기",
	"tags": [],
	"description": "",
	"content": "DynamoDB 생성하기 이번 랩은 DynamoDB를 사용해 사용자 정보와 대전 결과를 저장할 것입니다. 우리는 간단한 정보를 저장하고 또한 이 정보는 Web을 통해 접근할 수 있는 리더 보드에 사용될 것입니다. 추가로, DynamoDB 앞단에는 ElastiCache를 배치하여 리더 보드데이터를 캐싱하여 퍼블릭에 제공합니다. 왜냐하면 여러분의 App은 엄청난 인기를 끌게 될 것이고, 때문에 우리는 여러분의 DB가 동일한 요청을 수행하느라 부하가 걸리게 되길 원치 않습니다.\n모든 게임 결과는 SQS를 이용해 대기열에 들어가고 Lamdba를 활용하여 DB에 삽입할 것입니다. 그래서 결과를 테이블에 삽입할 때까지 기다리지 않아도 됩니다.이것은 또한 게임 흐름이 다른 구성 요소들이 끝날 때까지 기다리지 않아 플레이어에게 더 좋은 사용자 경험을 줄 수 있습니다. 수 많은 플레이어가 모두 처리해야하는 결과를 보내려고 할 때를 상상해보세요. 이것은 아마 혼란을 발생시키고 좋지 않은 사용자 경험을 주게 될 것입니다.\n자, 이제 DynamoDB 테이블을 만들어 보겠습니다.\nAWS 콘솔에 로그인하고 DynamoDB 페이지로 이동합니다. https://console.aws.amazon.com/dynamodb 리전을 확인합니다. 랩을 진행하면서 모든 서비스 요소들을 하나의 리전에서 생성하셔야 합니다. 콘솔에서 테이블 생성 버튼을 클릭하여 DynamoDB 테이블 생성을 시작합니다. Table name은 “GomokuPlayerInfo” 로 설정하고, Primary Key는 “PlayerName” 으로 하고 데이터 타입은 String을 선택합니다. 그리고 나서 테이블 생성 버튼을 클릭합니다\n테이블이 생성된 뒤에는 Stream을 활성화 합니다. 기본적으로 stream은 비활성화 되어 있습니다. 내보내기 및 스트림 탭을 클릭한 후, DynamoDB 스트림 세부 정보에서 활성화 버튼을 클릭합니다.\n새 이미지와 이전 이미지 를 선택하고 Enable버튼을 클릭합니다. 기본적인 작업은 끝났습니다. 이제 테스트 데이터 샘플을 만들어 줍니다. 오른쪽 상단의 표 항목 탐색을 선택 합니다.\n항목 생성 을 클릭하여 새로운 항목을 만들어줍니다.\n편집기에서 새 속성 추가 버튼을 클릭하고, 속성을 추가합니다.\n다음 스크린 캡처와 같아질 때까지 데이터를 계속 추가해줍니다. 그리고 항목 생성 버튼을 클릭하여 저장합니다. (데이터 타입에 주의해주세요)\n(*) Items tab에서 Scan, [테이블 이름] 을 선택하고 Start search버튼을 누르면 위에서 추가한 항목이 화면이 나타나는 것을 확인 할 수 있습니다.\n기본적인 DynamoDB 설정은 끝났습니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/intro/",
	"title": "GameLift HoL 소개",
	"tags": [],
	"description": "",
	"content": "GameLift 로 시작하는 Full Stack Game 지난 수개월간 만들어온 여러분의 게임이 드디어 완성을 앞두고 있습니다. \u0026ldquo;오목\u0026rdquo; 은 가로 세로 19칸으로 그어진 선 위에서 우주만물의 음과 양을 상징하는 검은 돌과 흰 돌을 사용하는 게임입니다. 두 명의 플레이어는 그들의 검은 돌과 흰 돌을 각각 격자에 놓게 되고, 처음으로 5개의 돌을 직선(혹은 대각선)으로 만든 플레이어가 승리하게 됩니다.\n하지만 게임은 만들었는데, 생각치 못한 점을 발견하게 됩니다. 이럴수가\u0026hellip; 오목은 혼자 할 수는 없다는 것이었죠! 여러분은 몇가지 AWS 서비스를 통해 \u0026ldquo;인터넷\u0026rdquo; 을 통한 플레이를 제공하기로 설정했습니다. 힘들 것 같나요? 하지만 이번 데모에서 게임은 이미 준비되어 있습니다.\n한가지만 명심하면 됩니다. 여러분에게는 큰 운영(Ops) 조직이 없기 때문에 Serverless 및 관리형 서비스를 활용하여 최대한 효율적이고 최적화된 방식을 활용해서 만들어야 합니다. 즉, API Gateway, Lambda, ElastiCache(Redis), S3, DynamoDB, SQS 그리고 GameLift 를 사용해서 Full Stack 을 만들어보겠습니다!\nToday\u0026rsquo;s Demo 오늘의 목표가 되는 게임입니다. 정말 재미있어 보이는군요! 재미있는 게임 만들기를 위해 하나하나 차근차근 따라가면서 실습을 진행하시는 것을 권장드립니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/flexmatch/lab21/",
	"title": "Lambda 함수 구성하기",
	"tags": [],
	"description": "",
	"content": "\rCloudFormation 스택을 배포하셨다면, 이미 Lambda 함수와 API Gateway 의 기본 틀은 마련되어 있습니다. 단계를 진행해보시면서 필요한 부분만 채워주시면 됩니다.\nLambda 함수 생성하기 이전 섹션까지 우리는 full stack game의 가장 기초적인 서비스들을 구성했습니다. 지금부터는 사용자가 게임을 즐기고 게임 결과를 처리할 Lambda 를 구성하겠습니다.\n이번 랩에서는 총 3개의 Lambda 함수를 생성할 것입니다. 먼저 첫 번째 Lambda 함수를 작성하는 방법입니다.\n콘솔에서 Lambda 메뉴로 이동합니다. https://console.aws.amazon.com/lambda\nCreate function 버튼을 클릭하여 첫번째 함수 생성을 시작합니다.\nAuthor from scratch 메뉴를 선택하여 빈 함수를 우선 생성합니다.\nName 항목에는 game-sqs-process를 입력합니다.\nRuntime은 Python 3.9을 선택합니다.\nPermissions 항목에서 Role 은 Use an existing role을 선택하고 기존에 만들어둔 Gomok-game-sqs-process를 선택하고 Create function을 실행합니다.\n생성이 완료되면 Designer그룹의 Add triggers 하단에 SQS(Simple Queue Service)를 Lambda의 실행 트리거로 선택합니다. 그러면 하단에 Configure triggers 그룹이 생성됩니다.\nSQS queue는 앞서 생성한 SQS의 arn이 선택되어 있는 것을 확인합니다. Enable trigger가 선택된 것을 확인하고 Add 버튼을 선택합니다. Basic settings: 128MB Memory and 1 min timeout\nDesigner 그룹으로 돌아와 아래의 생성할 함수의 정보를 참고하여 Lambda 함수를 작성합니다. 소스 경로 최상위의 Lambda 폴더를 보면 GameResultProcessing.py 함수 내용을 참고해서 Lambda 함수를 작성합니다. Code: GameResultProcessing.py 파일의 내용을 Copy\u0026amp;Paste합니다. 코드 내의 region_name 부분은 여러분이 랩을 수행하는 리전으로 되어 있는지 확인합니다. (예: ap-northeast-2)\nLambda 함수 핸들러 정보 구성에 유의합니다. Lambda 함수는 실행 시, Handler 에 지정된 함수를 참고하며 이 때 지정된 함수에 접근 가능해야 합니다.\nSave 버튼을 클릭하여 함수를 생성합니다. 생성한 함수는 SQS 에 기록된 게임 결과 점수를 읽어와 DynamoDB 에 업데이트하는 역할을 수행합니다. Lambda 함수는 SQS 대기열을 지속적으로 폴링하며 메시지를 가져와 DynamoDB 에 점수 결과를 반영합니다. 실습의 편의를 위하여 Python Package 를 별도의 바이너리 형태로 제공합니다. 즉, GetRank.py 와 Scoring.py 를 이용한 Lambda 함수 작성은 제공받은 바이너리 안에 Lambda/LambdaDeploy 경로를 참고합니다. 바이너리 다운로드는 실습 사전 준비 항목을 참고해주세요.\n두 번째 Lambda 함수는 Python 패키지를 업로드하여 생성합니다. 이전에 생성한 함수는 Python 표준 SDK만을 사용하기 때문에 인라인 편집기를 사용했지만, 다른 Lambda 함수들은 Redis 라이브러리를 참조하기 때문에 배포 패키지를 업로드 하여 함수를 생성할 것입니다. Lambda 함수를 Python 배포 패키지를 업로드하여 생성해볼 수 있는 아주 좋은 기회입니다.\nLambda 폴더 하위에 LambdaDeploy 폴더에 GetRank.py와 Scoring.py라는 두 개의 Python 파일이 보일 것입니다.\n두 개의 파일 모두 저장한 뒤, 다시 LambdaDeploy.zip으로 압축해줍니다. (참고: “LambdaDeploy”폴더가 압축파일에 포함되면 안됩니다. 즉, GetRank.py 및 Scoring.py파일은 압축파일 내의 루트경로에 있어야 합니다.)\n배포 패키지를 완성하면 이를 이용해서 Lambda 함수를 생성할 수 있습니다.\n앞 서와 동일하게 Author from scratch 메뉴를 선택하여 함수 생성을 시작합니다.\nName은 game-rank-update으로 지정하고, Runtime은 Python 3.9로 선택하고, Role은 Gomok-game-rank-update을 선택하고 Create function을 누릅니다.\nFunction code 그룹에서 Action Tab 을 눌러 Upload a .ZIP file로 선택하고 LambdaDeploy.zip을 업로드합니다.\nHandler 항목에서는 Scoring.handler 를 입력하고, 환경 변수에 다음과 같이 ElastiCache Endpoint 를 입력해줍니다. 이와 같이 Lambda 의 환경변수를 이용하면, 안전하게 엔드포인트를 관리할 수 있고, 소스에 하드코딩할 필요없이 효율적으로 관리할 수 있습니다.\n다음과 같이 환경변수로 REDIS 엔드포인트를 알맞게 구성합니다. 하단의 기본 설정 그룹에서 Timeout을 1분으로 변경합니다\nNetwork 항목에서 VPC를 기존에 생성한 ElastiCache가 있는 VPC로 선택합니다. 서브넷 항목은 모두 선택하여 주시고, Security Group은 이전에 생성했던 GomokuDefault로 선택하여 주시기 바랍니다\n상단의 Designer 그룹의 Add triggers에서 DynamoDB을 선택합니다. 하단에 Configure triggers그룹에서 GomokuPlayerInfo DynamoDB 테이블을 Trigger 테이블로 사용할 것입니다. 다른 부분은 기본값을 유지하고 Starting position은 수평 트리밍을 선택합니다. Enable trigger를 체크한 뒤 Add 버튼을 클릭합니다. 위의 과정이 완료되면 오른쪽 상단의 Save를 눌러 함수 생성을 완료합니다. (이 단계에서 함수 Test를 누르게 되면 아직 실패합니다.) 마지막으로 세번째 Lambda 함수를 생성하겠습니다. 두번째 만든 함수와 동일하게 만들 수 있습니다.\n세 번째 함수도 Author from scratch 를 선택하여 생성합니다.\nName항목에서 game-rank-reader를 입력하고, Runtime을 Python 3.9로 설정하고 Role을 이전에 만들어둔 Gomok-game-rank-reader를 선택합니다.\nCreate function을 누른 후 함수 코드의 작업 메뉴에서 Upload a .ZIP file을 선택하여 LambdaDeploy.zip을 업로드합니다.\nHandler 부분에서 GetRank.handler를 입력합니다. 역시 환경 변수에 좀 전과 같이 \u0026ldquo;REDIS\u0026rdquo; 를 키로 입력하고 값에 ElastiCache Endpoint 를 입력해줍니다.\nBasic settings 부분에서 Timeout을 1 min으로 설정합니다. Network 부분에서 이전 함수 동일하게 VPC 를 기존에 생성한 ElastiCache 가 있는 VPC 로 선택합니다. subnet 항목은 모두 선택하여 주시고, Security Group 은 이전에 생성했던 GomokuDefault 로 선택하여 주시기 바랍니다.\n이제 Save 를 눌러 Lambda 함수를 생성합니다.\n여기까지 완료했다면 3 개의 Lambda 함수가 생성된 것을 확인하실 수 있습니다. (CloudFormation 구성의 경우 5개)\n이제 모든 Lambda 함수는 준비되었습니다. 지금부터는 이 함수를 실행할 방법이 필요합니다. 처음 생성한 두 함수는 SQS와 DynamoDB에 의해 호출될 것입니다. 하지만 마지막 함수는 trigger를 설정하지 않았습니다. 어떻게 해야 해당 함수를 호출할 수 있을까요? 여기에서 API Gateway를 사용할 것입니다. 이 부분은 다음 섹션에서 내용이 이어집니다.\n함수 흐름 테스트 여기까지 준비가 되면 Section 1과 2에서 만들어진 여러 요소들이 어떻게 동작하는지를 테스트해 볼 수 있습니다. 간략하게 설명하면 전체 흐름을 보면 SQS에 데이터가 삽입되면 만들어진 Lambda함수가 실행되면서 해당 SQS데이터를 DynamoDB에 업데이트합니다. Dynamo DB에 입력된 데이터는 DynamoDB Stream의 Trigger를 통하여 다른 Lambda함수가 실행되어 Redis Cache가 업데이트 되는 형태를 가지게 됩니다.\n간단하게 Redis Cache의 내용을 확인할수는 없으나 전체 흐름이 정상적으로 동작하는지 여부를 테스트 데이터의 입력과 CloudWatch를 통하여 확인해보도록 하겠습니다.\nConsole을 통하여 SQS를 열어줍니다. https://console.aws.amazon.com/sqs 위에서 생성한 game-result-queue를 선택하고 화면 위의 Queue Actions버튼을 눌러줍니다. 나오는 메뉴 중에서 Send Message를 선택합니다. 나오는 텍스트 상자에 아래의 JSON을 넣어줍니다. (특수 기호 때문에 붙여 넣기보다는 직접 입력을 추천합니다. 대소문자 구분에 주의하십시요. 정상 동작하지 않을 경우, CloudWatch Logs에 남아 있는 lambda 출력을 확인하세요.) { \u0026#34;PlayerName\u0026#34; : \u0026#34;SomeName\u0026#34; , \u0026#34;WinDiff\u0026#34; : 1, \u0026#34;LoseDiff\u0026#34; : 0, \u0026#34;ScoreDiff\u0026#34; : 100 } 그리고 Send Message버튼을 눌러줍니다. 이제 DynamoDB콘솔로 옮겨가서 GomokuPlayerInfo 테이블을 열어줍니다. Items 탭을 보면 위에서 넣어준 JSON데이터에 해당하는 항목이 반영되어 있는 것을 확인 할 수 있습니다. (이미 같은 PlayerName에 해당하는 항목이 있다면 Win이 1증가하고 Score가 100증가했을 것입니다.) 만약 반영이 되지 않을 경우 CloudWatch Logs 를 통해 메시지 처리 내역을 확인해볼 수 있습니다. "
},
{
	"uri": "/aws-gamelift-sample/ko/gamelift/lab41/",
	"title": "Lambda 함수 구성하기",
	"tags": [],
	"description": "",
	"content": "\rCloudFormation 스택을 배포하셨다면, 이미 Lambda 함수와 API Gateway 의 기본 틀은 마련되어 있습니다. 단계를 진행해보시면서 필요한 부분만 채워주시면 됩니다.\nLambda 함수 생성하기 1장에서 우리는 full stack game의 가장 기초적인 서비스들을 구성했습니다. 지금부터는 사용자가 게임을 즐기고 게임 결과를 처리할 Lambda 를 구성하겠습니다.\n이번 랩에서는 총 3개의 Lambda 함수를 생성할 것입니다. 먼저 첫 번째 Lambda 함수를 작성하는 방법입니다.\n콘솔에서 Lambda 메뉴로 이동합니다. https://console.aws.amazon.com/lambda\nCreate function 버튼을 클릭하여 첫번째 함수 생성을 시작합니다.\nAuthor from scratch 메뉴를 선택하여 빈 함수를 우선 생성합니다.\nName 항목에는 game-sqs-process를 입력합니다.\nRuntime은 Python 3.9을 선택합니다.\nPermissions 항목에서 Role 은 Use an existing role을 선택하고 기존에 만들어둔 Gomok-game-sqs-process를 선택하고 Create function을 실행합니다.\n생성이 완료되면 Designer그룹의 Add triggers 하단에 SQS(Simple Queue Service)를 Lambda의 실행 트리거로 선택합니다. 그러면 하단에 Configure triggers 그룹이 생성됩니다.\nSQS queue는 앞서 생성한 SQS의 arn이 선택되어 있는 것을 확인합니다. Enable trigger가 선택된 것을 확인하고 Add 버튼을 선택합니다. Advanced settings: 128MB Memory and 1 min timeout\nDesigner 그룹으로 돌아와 아래의 생성할 함수의 정보를 참고하여 Lambda 함수를 작성합니다. 소스 경로 최상위의 Lambda 폴더를 보면 GameResultProcessing.py 함수 내용을 참고해서 Lambda 함수를 작성합니다. Code: GameResultProcessing.py 파일의 내용을 Copy\u0026amp;Paste합니다. 코드 내의 region_name 부분은 여러분이 랩을 수행하는 리전으로 되어 있는지 확인합니다. (예: ap-northeast-2)\nSave 버튼을 클릭하여 함수를 생성합니다. 생성한 함수는 SQS 에 기록된 게임 결과 점수를 읽어와 DynamoDB 에 업데이트하는 역할을 수행합니다. Lambda 함수는 SQS 대기열을 지속적으로 폴링하며 메시지를 가져와 DynamoDB 에 점수 결과를 반영합니다. 실습의 편의를 위하여 Python Package 를 별도의 바이너리 형태로 제공합니다. 즉, GetRank.py 와 Scoring.py 를 이용한 Lambda 함수 작성은 제공받은 바이너리 안에 Lambda/LambdaDeploy 경로를 참고합니다.\n두 번째 Lambda 함수는 Python 패키지를 업로드하여 생성합니다. 이전에 생성한 함수는 Python 표준 SDK만을 사용하기 때문에 인라인 편집기를 사용했지만, 다른 Lambda 함수들은 Redis 라이브러리를 참조하기 때문에 배포 패키지를 업로드 하여 함수를 생성할 것입니다. Lambda 함수를 Python 배포 패키지를 업로드하여 생성해볼 수 있는 아주 좋은 기회입니다.\n소스 코드를 작성(수정)한 후 배포 패키지 형태로 묶은 다음(LambdaDeploy.zip 파일) 이를 업로드하여 Lambda 함수를 생성할 것입니다. (만약 배포 패키지를 어떻게 직접 만드는지 알고 싶으시다면 Appendix A를 참조하세요.)\nLambda 폴더 하위에 LambdaDeploy 폴더에 GetRank.py와 Scoring.py라는 두 개의 Python 파일이 보일 것입니다.\n두 개의 파일 모두 저장한 뒤, 다시 LambdaDeploy.zip으로 압축해줍니다. (참고: “LambdaDeploy”폴더가 압축파일에 포함되면 안됩니다. 즉, GetRank.py 및 Scoring.py파일은 압축파일 내의 루트경로에 있어야 합니다.)\n배포 패키지를 완성하면 이를 이용해서 Lambda 함수를 생성할 수 있습니다.\n앞 서와 동일하게 Author from scratch 메뉴를 선택하여 함수 생성을 시작합니다.\nName은 game-rank-update으로 지정하고, Runtime은 Python 3.9로 선택하고, Role은 Gomok-game-rank-update을 선택하고 Create function을 누릅니다.\nFunction code그룹에서 Code entry type을 Upload a .ZIP file로 선택하고 LambdaDeploy.zip을 업로드합니다.\nHandler 항목에서는 Scoring.handler 를 입력하고, 환경 변수에 다음과 같이 ElastiCache Endpoint 를 입력해줍니다. 이와 같이 Lambda 의 환경변수를 이용하면, 안전하게 엔드포인트를 관리할 수 있고, 소스에 하드코딩할 필요없이 효율적으로 관리할 수 있습니다.\n하단의 기본 설정 그룹에서 Timeout을 1분으로 변경합니다\nNetwork 항목에서 VPC를 기존에 생성한 ElastiCache가 있는 VPC로 선택합니다. 서브넷 항목은 모두 선택하여 주시고, Security Group은 이전에 생성했던 GomokuDefault로 선택하여 주시기 바랍니다\n상단의 Designer 그룹의 Add triggers에서 DynamoDB을 선택합니다. 하단에 Configure triggers그룹에서 GomokuPlayerInfo DynamoDB 테이블을 Trigger 테이블로 사용할 것입니다. 다른 부분은 기본값을 유지하고 Starting position은 수평 트리밍을 선택합니다. Enable trigger를 체크한 뒤 Add 버튼을 클릭합니다. 위의 과정이 완료되면 오른쪽 상단의 Save를 눌러 함수 생성을 완료합니다. (이 단계에서 함수 Test를 누르게 되면 아직 실패합니다.) 마지막으로 세번째 Lambda 함수를 생성하겠습니다. 두번째 만든 함수와 동일하게 만들 수 있습니다.\n세 번째 함수도 Author from scratch 를 선택하여 생성합니다.\nName항목에서 game-rank-reader를 입력하고, Runtime을 Python 3.9로 설정하고 Role을 이전에 만들어둔 Gomok-game-rank-reader를 선택합니다.\nCreate function을 누른 후 Code entry type에서 Upload a .ZIP file을 선택하여 LambdaDeploy.zip을 업로드합니다.\nHandler 부분에서 GetRank.handler를 입력합니다. 역시 환경 변수에 좀 전과 같이 ElastiCache Endpoint 를 입력해줍니다.\nBasic settings 부분에서 Timeout을 1 min으로 설정합니다. Network 부분에서 이전 함수 동일하게 VPC 를 기존에 생성한 ElastiCache 가 있는 VPC 로 선택합니다. subnet 항목은 모두 선택하여 주시고, Security Group 은 이전에 생성했던 GomokuDefault 로 선택하여 주시기 바랍니다.\n이제 Save 를 눌러 Lambda 함수를 생성합니다.\n여기까지 완료했다면 3 개의 Lambda 함수가 생성된 것을 확인하실 수 있습니다.\n이제 모든 Lambda 함수는 준비되었습니다. 지금부터는 이 함수를 실행할 방법이 필요합니다. 처음 생성한 두 함수는 SQS와 DynamoDB에 의해 호출될 것입니다. 하지만 마지막 함수는 trigger를 설정하지 않았습니다. 어떻게 해야 해당 함수를 호출할 수 있을까요? 여기에서 API Gateway를 사용할 것입니다. 이 부분은 다음 섹션에서 내용이 이어집니다.\n함수 흐름 테스트 여기까지 준비가 되면 Section 1과 2에서 만들어진 여러 요소들이 어떻게 동작하는지를 테스트해 볼 수 있습니다. 간략하게 설명하면 전체 흐름을 보면 SQS에 데이터가 삽입되면 만들어진 Lambda함수가 실행되면서 해당 SQS데이터를 DynamoDB에 업데이트합니다. Dynamo DB에 입력된 데이터는 DynamoDB Stream의 Trigger를 통하여 다른 Lambda함수가 실행되어 Redis Cache가 업데이트 되는 형태를 가지게 됩니다.\n간단하게 Redis Cache의 내용을 확인할수는 없으나 전체 흐름이 정상적으로 동작하는지 여부를 테스트 데이터의 입력과 CloudWatch를 통하여 확인해보도록 하겠습니다.\nConsole을 통하여 SQS를 열어줍니다. https://console.aws.amazon.com/sqs\n위에서 생성한 game-result-queue를 선택하고 화면 위의 Queue Actions버튼을 눌러줍니다.\n나오는 메뉴 중에서 Send Message를 선택합니다.\n나오는 텍스트 상자에 아래의 JSON을 넣어줍니다. (특수 기호 때문에 붙여 넣기보다는 직접 입력을 추천합니다. 대소문자 구분에 주의하십시요. 정상 동작하지 않을 경우, CloudWatch Logs에 남아 있는 lambda 출력을 확인하세요.) { \u0026ldquo;PlayerName\u0026rdquo; : \u0026ldquo;SomeName\u0026rdquo; , \u0026ldquo;WinDiff\u0026rdquo; : 1, \u0026ldquo;LoseDiff\u0026rdquo; : 0, \u0026ldquo;ScoreDiff\u0026rdquo; : 100 }\n그리고 Send Message버튼을 눌러줍니다.\n이제 DynamoDB콘솔로 옮겨가서 GomokuPlayerInfo 테이블을 열어줍니다. Items 탭을 보면 위에서 넣어준 JSON데이터에 해당하는 항목이 반영되어 있는 것을 확인 할 수 있습니다. (이미 같은 PlayerName에 해당하는 항목이 있다면 Win이 1증가하고 Score가 100증가했을 것입니다.)\n만약 반영이 되지 않을 경우 CloudWatch 를 통해 메시지 처리 내역을 확인해볼 수 있습니다. "
},
{
	"uri": "/aws-gamelift-sample/ko/intro/lab01/",
	"title": "워크샵 내용 구성",
	"tags": [],
	"description": "",
	"content": "실습 목표 - GameLift 를 이용해서 세션 기반 매칭 게임을 구성해보실 수 있습니다. - GameLift 와 FlexMatch 기능을 통해 서버리스 기반의 매칭 시스템을 도입할 수 있습니다. - FlexMatch 의 Advanced 한 기능들을 통해 향상된 세션 매칭 규칙 테스팅과 티켓 모니터링 기능을 추가할 수 있습니다. - 독립형 FleetIQ 기능을 이용해 보다 유연하고 저렴한 세션 게임 아키텍처를 시작하실 수 있습니다.\n실습 목차 소개 1장 - Full Stack 게임 구성을 위해 실습에 필요한 서비스를 구성합니다. (이 단계는 CloudFormation 으로 한 번에 구성하실 수도 있습니다) 2장 - FlexMatch 기능을 활용해 게임 매칭에 있어서 향상된 기능을 배워봅니다. 3장 - FleetIQ 기능을 이용해 또다른 방식으로 게임 서버를 구성해볼 수 있습니다. 4장 - 4장 실습에서는 GameLift 의 구버전 기능을 활용한 실습을 수행해봅니다. 직접 매치메이커 서버를 운영하고 멀티 플레이 게임을 구현해봅니다. 5장 - 실습 도중 구성된 게임 스택을 정리해봅니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/intro/lab02/",
	"title": "실습 사전 준비",
	"tags": [],
	"description": "",
	"content": "실습 소스 및 바이너리 파일 다운로드 실습에 사용되는 소스 파일은 다음 위치에서 다운로드할 수 있습니다. https://github.com/aws-samples/aws-gamelift-sample\n실습에서는 빌드 과정의 부담을 덜기 위해 사전 빌드된 바이너리를 제공합니다. 각 과정에서 필요한 바이너리 파일들은 위에서 받을 수 있는 루트 폴더의 bin 폴더 하위에 존재합니다. 다음 링크에서 완성된 바이너리 파일의 형태를 다운받으실 수도 있습니다. http://d2511y3q5icxx2.cloudfront.net/DemoBinary.zip\n보다 자세한 사항은 각 실습 항목에서 설명을 참고합니다.\nAWS CLI 설치 본 실습을 위해서는 최신 버전의 CLI 사용이 권고됩니다. 만약 AWS CLI 가 설치되어 있지 않다면 다음 링크를 참고해서 설치하실 수 있습니다. https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/install-cliv1.html AWS CLI v2 설치 (옵션) FleetIQ 실습을 위해서는 CLI v2 가 필요합니다. 다음 링크로부터 CLI 커맨드를 실행할 환경에서 CLI 버전 2를 설치하도록 합니다. Windows : https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/install-cliv2-windows.html Mac OS : https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/install-cliv2-mac.html Linux : https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/install-cliv2-linux.html Windows 환경 구성 GameLift 및 FlexMatch 실습은 Visual Studio 2015 에서 개발된 바이너리에 기반합니다. 윈도우 환경 구성을 위해 서버 및 클라이언트 환경에 다음 C++ 재배포 가능 패키지가 요구됩니다. https://www.microsoft.com/en-us/download/details.aspx?id=48145 "
},
{
	"uri": "/aws-gamelift-sample/ko/flexmatch/lab22/",
	"title": "API Gateway 구성하기",
	"tags": [],
	"description": "",
	"content": "\rCloudFormation 스택을 배포하셨다면, 이미 Lambda 함수와 API Gateway 의 기본 틀은 마련되어 있습니다. 단계를 진행해보시면서 필요한 부분만 채워주시면 됩니다.\nAPI Gateway 구성하기 우리의 Lambda 함수 중 한가지가 API Gateway를 필요로 한다는 것을 알고 있습니다. API Gateway 는 REST API, HTTP API, WebSocket API 에 대한 엔드포인트로 API 캐싱이나 스로틀링과 같은 다양한 기능과 운영에 있어서 이점을 제공합니다. 이것은 개발 중의 애플리케이션의 Lambda 함수를 실행할 일종의 “Gateway” 역할을 하기 때문에 API Gateway라 이름이 붙여졌으며, 본 실습에서 API Gateway 는 Lambda 를 위한 API 엔드포인트의 역할을 수행합니다.\n우선 콘솔에서 API Gateway 메뉴로 이동합니다. (https://console.aws.amazon.com/apigateway)\nCreate API를 선택하고, API name은 GomokuAPI 를 입력한 뒤 Create API 버튼을 클릭합니다\nAPI가 생성된 뒤에는 빈 화면이 나타납니다. 우선 Resource 를 만들고 그 Resource 에 Method 를 생성합니다. Actions 버튼을 클릭하고 Resource 를 만듭니다.\n아래와 같이 Resource Name에 ranking을 입력하고 Enable API Gateway CORS를 선택합니다. Create Resource를 클릭합니다.\n다음은 새로운 Method를 생성하는 것입니다. Actions 버튼을 클릭한 뒤 Create Method 메뉴를 선택합니다. 아래 작은 리스트박스가 보일 것입니다. GET을 선택한 뒤 옆의 체크 버튼을 클릭합니다.\nGET 메소드의 상세 설정에서 Integration type은 Lambda Function을 선택하고 Lambda Region에 실습을 진행 중인 Region을 선택합니다. Lambda Function에는 앞서 생성한 game-rank-reader를 선택한 뒤 Save 버튼을 클릭합니다.\nAPI 구성이 되었습니다. 이제 prod 단계에 배포를 해보겠습니다. Actions 버튼을 클릭하고 Deploy API 메뉴를 클릭합니다.\n[New Stage] 를 선택하고 Stage name에는 prod를 입력합니다. Deploy 버튼을 클릭하여 진행합니다.\n완료되면 다음 스크린 캡처와 같이 Stage 구성이 된 것을 확인할 수 있습니다. Prod 배포의 /ranking 메뉴 하단의 GET을 선택하면 나오는 Invoke URL을 기록해둡니다. 다음 단원에서 S3 를 이용한 정적 웹페이지 구성에 사용됩니다. 이제 S3가 호스팅하는 웹 사이트를 생성할 것입니다. 버킷에 Ranking board html파일과 Javascript 파일을 업로드하는 것만으로 쉽게 웹 사이트를 호스팅할 수 있습니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/gamelift/lab42/",
	"title": "API Gateway 구성하기",
	"tags": [],
	"description": "",
	"content": "\rCloudFormation 스택을 배포하셨다면, 이미 Lambda 함수와 API Gateway 의 기본 틀은 마련되어 있습니다. 단계를 진행해보시면서 필요한 부분만 채워주시면 됩니다.\nAPI Gateway 구성하기 우리의 Lambda 함수 중 한가지가 API Gateway를 필요로 한다는 것을 알고 있습니다. REST API, HTTP API, WebSocket API 에 대한 엔드포인트로 API 캐싱이나 스로틀링과 같은 다양한 기능과 운영에 있어서 이점을 제공합니다. 이것은 개발 중의 애플리케이션의 Lambda 함수를 실행할 일종의 “Gateway” 역할을 하기 때문에 API Gateway라 이름이 붙여졌으며, 본 실습에서 API Gateway 는 Lambda 를 위한 API 엔드포인트의 역할을 수행합니다.\n우선 콘솔에서 API Gateway 메뉴로 이동합니다. (https://console.aws.amazon.com/apigateway)\nCreate API를 선택하고, API name은 GomokuAPI 를 입력한 뒤 Create API 버튼을 클릭합니다\nAPI가 생성된 뒤에는 빈 화면이 나타납니다. 우선 Resource 를 만들고 그 Resource 에 Method 를 생성합니다. Actions 버튼을 클릭하고 Resource 를 만듭니다.\n아래와 같이 Resource Name에 ranking을 입력하고 Enable API Gateway CORS를 선택합니다. Create Resource를 클릭합니다.\n다음은 새로운 Method를 생성하는 것입니다. Actions 버튼을 클릭한 뒤 Create Method 메뉴를 선택합니다. 아래 작은 리스트박스가 보일 것입니다. GET을 선택한 뒤 옆의 체크 버튼을 클릭합니다.\nGET 메소드의 상세 설정에서 Integration type은 Lambda Function을 선택하고 Lambda Region에 실습을 진행 중인 Region을 선택합니다. Lambda Function에는 앞서 생성한 game-rank-reader를 선택한 뒤 Save 버튼을 클릭합니다.\nAPI 구성이 되었습니다. 이제 prod 단계에 배포를 해보겠습니다. Actions 버튼을 클릭하고 Deploy API 메뉴를 클릭합니다.\n[New Stage] 를 선택하고 Stage name에는 prod를 입력합니다. Deploy 버튼을 클릭하여 진행합니다.\n완료되면 다음 스크린 캡처와 같이 Stage 구성이 된 것을 확인할 수 있습니다. Prod 배포의 /ranking 메뉴 하단의 GET을 선택하면 나오는 Invoke URL을 기록해둡니다. 다음 단원에서 S3 를 이용한 정적 웹페이지 구성에 사용됩니다. 이제 S3가 호스팅하는 웹 사이트를 생성할 것입니다. 버킷에 Ranking board html파일과 Javascript 파일을 업로드하는 것만으로 쉽게 웹 사이트를 호스팅할 수 있습니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/awsservice/lab12/",
	"title": "ElastiCache 구성",
	"tags": [],
	"description": "",
	"content": "ElastiCache 구성하기 다음으로 ElastiCache를 설정합니다. 이것은 순위 정보를 저장할 것입니다.\nAWS 콘솔에서 ElastiCache로 이동합니다. https://console.aws.amazon.com/elasticache ElastiCache cluster를 생성합니다. 우리는 Redis 엔진을 사용할 것입니다. 왼쪽 메뉴에서 Redis 클러스터를 선택 후 Redis 클러스터 생성을 클릭 합니다. 다음 스크립 캡처와 같이 필요한 정보를 입력해줍니다. 따로 설명이 되어있지 않은 설정은 모두 default로 진행합니다.\nName: gomokuranking\nEngine: 6.2 (5.0.4 이상의 버전을 권고드립니다)\nPort: 6379 (default)\nParameter group: default\nNumber of replicas: 0\n서브넷 그룹 설정에서는, 기존의 default vpc 및 subnet 을 선택하셔도 되고 실습을 위한 vpc 및 subnet group을 새로 생성하실 수도 있습니다. 모든 설정이 완료되면, Create 버튼을 클릭하여 Redis 클러스터를 생성합니다. (시간이 조금 걸리기 때문에 다음 단계인 SQS 생성을 먼저 진행할 수도 있습니다. ) 생성한 Redis 클러스터의 상태가 available이 되면 Primary Endpoint를 따로 기록해둡니다. 추후 Lambda 생성 시에 해당 Endpoint가 사용됩니다. 생성한 ElastiCache의 보안을 강화하기 위하여 gomokuranking 클러스터에 안전한 보안 그룹을 생성하여 할당합니다. 이번 실습에서는 아주 간단한 보안그룹 정책을 생성하여 할당하겠습니다. VPC 콘솔에서 https://console.aws.amazon.com/vpc 좌측의 보안 그룹 메뉴를 선택하고 보안 그룹 생성 버튼을 클릭합니다. Name tag, Group name 등에 적절한 정보를 입력해주고, VPC는 실습을 진행 중인 default VPC를 선택합니다. (리전에 VPC가 하나라면 default가 따로 표시되지는 않습니다) 보안 그룹 내의 통신을 위하여 inbound 정책을 수정해야 합니다. 생성한 보안 그룹을 선택하고 인바운드 규칙 탭을 클릭합니다. 인바운드 규칙 추가 버튼을 클릭하고 다음 스크린 캡처와 같이 정책을 생성합니다. 여기서 Source 에는 보안 정책 자신의 Group ID를 입력합니다. 이렇게 함으로써 이 보안 그룹을 할당한 호스트와 서비스들끼리 통신을 할 수 있습니다. 생성한 보안 그룹을 기억해 둡니다. Type: All traffic Protocol: All Source: Security Group itself 보안 그룹 생성을 완료하였다면 다시 ElastiCache 페이지로 돌아와 생성한 Redis 클러스터를 선택합니다. 클러스터를 선택하고 상단의 수정 버튼을 클릭하고, 수정 페이지의 보안 항목에서 방금 생성한 Security Group 을 선택한 뒤 반영합니다. ElastiCache 설정을 완료하였습니다. 다음으로 SQS 설정을 할 차례입니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/awsservice/",
	"title": "풀스택 AWS 서비스 구성",
	"tags": [],
	"description": "",
	"content": "\r이번 Lab에서는 본격적으로 게임을 만들기 앞서, 멀티플레이 게임을 더 풍부하게 만들 수 있는 사용자 데이터베이스와 게임 결과를 처리하는 큐, 및 각종 AWS 리소스 접근을 위한 권한 등을 생성해볼 것입니다.\nCloudFormation 으로 실습 단계 간소화 이 장의 단계는 CloudFormation 을 이용한 자동화된 스택으로 간소화할 수 있습니다. 보다 빠른 진행을 원하신다면, 다음 링크를 참조해주세요.\nCloudFormation 을 통해 빠른 실습 진행 위의 단계 진행 이후에는 바로 2장으로 넘어가실 수 있습니다.\n직접 AWS 서비스 스택 구성 직접 풀스택 게임 구성을 위한 AWS 서비스들을 생성하실 수 있습니다. 1-1 부터의 단계에서 시작합니다.\n사용자 정보 저장을 위한 DynamoDB 만들기 리더 보드 제작을 위한 ElastiCache 구성 게임 결과 처리를 위한 SQS 만들기 AWS 리소스 접근을 위한 IAM 정책 및 역할 생성 "
},
{
	"uri": "/aws-gamelift-sample/ko/intro/lab03/",
	"title": "실습 사전 지식",
	"tags": [],
	"description": "",
	"content": "\r본 실습은 풀스택 게임 서비스를 만들기 위해 다양한 AWS 서비스들을 이용합니다. 이번 장에서는 실습에서 사용되는 몇가지 서비스들을 간략하게 가이드합니다.\nGameLift Amazon GameLift 는 세션 기반 멀티플레이어 게임을 위해 제공되는 관리형 AWS 서비스입니다. GameLift 는 AWS 글로벌 컴퓨팅 인프라 기반위에서 고성능과 높은 안정성을 제공하며, 비용 효율적으로 리소스를 사용할 수 있도록 지원합니다. 현재 GameLift 는 세션 기반 게임을 위한 관리형 호스팅, Realtime 서버 구축을 위한 관리형 호스팅, 그리고 EC2 에서의 직접 게임 호스팅을 위한 독립형 FleetIQ 기능을 제공합니다. https://docs.aws.amazon.com/ko_kr/gamelift/latest/developerguide/gamelift-intro.html DynamoDB Amazon DynamoDB 는 AWS 에서 제공하는 관리형 NoSQL 데이터베이스로, 뛰어난 확장성과 내구성, 고성능을 제공하는 분산 데이터베이스입니다. Database Connection 관리 및 분산 환경에서 뛰어난 확장성으로 인해 Lambda 기반의 서버리스 아키텍처에서도 우수하게 사용될 수 있는 데이터베이스입니다. 높은 수준의 트래픽을 처리할 수 있으며 클라우드 기반 분산 환경에 적합한 데이터베이스로, 본 실습에서는 유저 정보 저장을 위해 DynamoDB 를 사용합니다. https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/Introduction.html ElastiCache Amazon ElastiCache 는 Redis 및 Memcached 와 호환되는 완전관리형 인메모리 데이터베이스입니다. 고성능의 캐시를 제공하는 인메모리 데이터베이스로, 이번 실습에서는 랭킹정보 관리를 위한 캐시로 사용됩니다. https://docs.aws.amazon.com/ko_kr/AmazonElastiCache/latest/red-ug/WhatIs.html SQS Amazon SQS 는 뛰어난 내구성을 제공하는 대기열을 제공합니다. 이를 통해 분산 시스템 아키텍처에서 컴포넌트들을 디커플링하여 보다 유연한 아키텍처를 구성하실 수 있습니다. 이번 실습에서는 게임 결과를 SQS 를 통해 처리하는 식으로 구현합니다. https://docs.aws.amazon.com/ko_kr/AWSSimpleQueueService/latest/SQSDeveloperGuide/welcome.html Lambda AWS Lambda 는 서버를 프로비저닝하거나 관리하지 않고도 코드를 실행할 수 있도록 제공해주는 컴퓨팅 서비스입니다. 별도의 컴퓨팅 인프라 구성이 필요없이 필요할 때에만 쉽게 서비스를 시작할 수 있는 서버리스 아키텍처의 핵심 서비스입니다. 이번 실습에서는 각종 API 처리를 Lambda 로 구성합니다. https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/welcome.html API Gateway Amazon API Gateway 는 규모에 관계없이 REST API 및 WebSocket API 를 제공할 수 있도록 지원하는 서비스입니다. 쉽고 다양한 기능을 기반으로 API 구성을 시작할 수 있습니다. 이번 실습에서는 Lambda 를 API Gateway 를 이용해서 트리거합니다. https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/welcome.html S3 Amazon S3 는 인터넷으로 제공되는 오브젝트 스토리지 서비스입니다. S3 를 통해 쉽게 웹 기반 워크로드에서 스토리지를 사용하고 웹서비스를 호스팅할 수 있습니다. 이번 실습에서는 S3 를 이용해서 유저들의 정보를 조회하는 웹 호스팅을 시작합니다. https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/dev/Welcome.html "
},
{
	"uri": "/aws-gamelift-sample/ko/flexmatch/",
	"title": "GameLift FlexMatch 실습",
	"tags": [],
	"description": "",
	"content": "GameLift 서비스와 함께 게임 서버 구축 본 실습에서는 다양한 구현 아키텍처를 보여주기 위하여 FlexMatch 기능은 서버리스 매치메이킹을 이용합니다.\n이 내용은 GameLift Classic 실습 내용과 차이가 있습니다.\nArchitecture Diagram (FlexMatch) 다음 아키텍처는 FlexMatch 실습의 아키텍처입니다.\nFlexMatch 의 내부 동작 로직은 기존 GameLift 의 사용과는 다릅니다. GameLift FlexMatch 기능을 사용하면 보다 다양한 기능을 높은 유연성을 가지고 설계할 수 있습니다. 다음 아키텍처는 본 실습 과정에서의 이해를 돕기 위해 FlexMatch 의 구성에 대해 설명합니다.\n기존에 별도의 매치메이커 서버를 두고, GameLift 가 관리하는 플릿의 인스턴스에 세션 게임 서버를 배치했었던 구조에서 서버리스 기반의 매치메이킹 구조로 바뀌었습니다. 이제, 매치 요청이 들어올 때에만 서버가 효율적으로 실행되고 매치메이킹 서버에 대한 관리 부담을 줄이면서 게임 세션을 매칭할 수 있습니다.\n실습 목차 실습은 다음과 같은 순서로 진행됩니다.\nLambda 함수 구성 API Gateway 구성 S3 웹 호스팅 환경 구성 게임 서버 빌드 및 플릿 생성 서버리스 기반의 FlexMatch 로직 및 Lambda API 구성하기 FlexMatch 게임 클라이언트와 환경을 연결 (게임 플레이!) FlexMatch 매치메이킹 이벤트 활용 FlexMatch Ruleset 테스트 "
},
{
	"uri": "/aws-gamelift-sample/ko/flexmatch/lab23/",
	"title": "S3 웹 호스팅",
	"tags": [],
	"description": "",
	"content": "S3 웹 호스팅을 통한 랭킹 리더보드 구현 앞서 우리는 데이터베이스들을 구축했고, API Gateway 와 Lambda 함수를 통해 유저 정보를 다룰 수 있는 API 를 구축했습니다. 이번에는 S3 가 호스팅하는 웹 사이트를 생성하고 이를 이용해서 쉽게 랭킹보드를 구현할 것입니다.\nS3 서비스로 이동하여 웹 사이트에 사용할 S3 버킷을 생성합니다. 버킷 생성 시, public object를 허용하기 위해 Block all public access를 uncheck합니다. 실습에 사용되는 파일 중 web 디렉토리가 있을 것입니다. 디렉토리 내의 main.js 파일을 텍스트 편집기로 엽니다.\n48번째 줄의 API Endpoint에 위에서 생성한 API Gateway의 Invoke URL로 수정합니다.\n수정한 main.js를 저장한 뒤 web 디렉토리의 파일을 전부 앞서 생성한 버킷에 업로드해줍니다\n업로드할 때 Public read access 권한을 부여합니다.\n버킷에서 Static website hosting을 활성화해주어야 합니다. 버킷의 Properties 탭으로 이동합니다.\nStatic website hosting을 활성화합니다. Index document에는 index.html을 입력한 뒤 Save 버튼을 클릭합니다. 파일 업로드를 완료하면 Static website hosting의 Endpoint로 접속하여 단순한 웹 페이지를 확인할 수 있습니다.\nAPI Gateway로 돌아와서 CORS 설정을 해주어야 합니다. 이를 통해 Ranking board 정보를 웹 페이지에서 읽어 올 수 있게 됩니다.\nAPI Gateway로 돌아와서 Actions버튼을 클릭하고 Enable CORS 옵션을 선택합니다.\nCORS 페이지에서 Access-Control-Allow-Origin 에 static website URL로 수정해줍니다. (URL 뒤의 / 가 영향을 미칠 수 있기 때문에 확실하지 않으면 기본 값인 * 로 진행합니다.)\nEnable CORS 버튼을 클릭하여 진행합니다.\n정상적으로 완료되었다면 왼쪽 탭에 OPTIONS 가 추가된 것을 확인할 수 있습니다.\n마지막으로 Actions 메뉴의 Deploy API 버튼을 클릭하여 prod 단계에 배포합니다.\n배포한 Static Page를 웹브라우저에서 열어주거나 API 의 Invoke URL을 브라우저에서 열어주시면 Section 2에서 테스트로 입력했던 데이터가 표시되거나 JSON(직접 Invoke URL을 열었을 경우) 으로 표기 되는 것을 확인 할 수 있습니다.\n이 섹션에서 구성한 웹페이지는 다음과 같이 랭킹 보드를 위한 목적으로 사용될 예정입니다.\n이제 게임을 위한 기반 작업들을 마무리했습니다. :) 본격적으로 게임 서버를 구축할 시간입니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/gamelift/lab43/",
	"title": "S3 웹 호스팅",
	"tags": [],
	"description": "",
	"content": "S3 웹 호스팅을 통한 랭킹 리더보드 구현 앞서 우리는 데이터베이스들을 구축했고, API Gateway 와 Lambda 함수를 통해 유저 정보를 다룰 수 있는 API 를 구축했습니다. 이번에는 S3 가 호스팅하는 웹 사이트를 생성하고 이를 이용해서 쉽게 랭킹보드를 구현할 것입니다.\nS3 서비스로 이동하여 웹 사이트에 사용할 S3 버킷을 생성합니다. 버킷 생성 시, public object를 허용하기 위해 Block all public access를 uncheck합니다. 실습에 사용되는 파일 중 web 디렉토리가 있을 것입니다. 디렉토리 내의 main.js 파일을 텍스트 편집기로 엽니다.\n48번째 줄의 API Endpoint에 위에서 생성한 API Gateway의 Invoke URL로 수정합니다.\n수정한 main.js를 저장한 뒤 web 디렉토리의 파일을 전부 앞서 생성한 버킷에 업로드해줍니다\n업로드할 때 Public read access 권한을 부여합니다.\n버킷에서 Static website hosting을 활성화해주어야 합니다. 버킷의 Properties 탭으로 이동합니다.\nStatic website hosting을 활성화합니다. Index document에는 index.html을 입력한 뒤 Save 버튼을 클릭합니다. 파일 업로드를 완료하면 Static website hosting의 Endpoint로 접속하여 단순한 웹 페이지를 확인할 수 있습니다.\nAPI Gateway로 돌아와서 CORS 설정을 해주어야 합니다. 이를 통해 Ranking board 정보를 웹 페이지에서 읽어 올 수 있게 됩니다.\nAPI Gateway로 돌아와서 Actions버튼을 클릭하고 Enable CORS 옵션을 선택합니다.\nCORS 페이지에서 Access-Control-Allow-Origin 에 static website URL로 수정해줍니다. (URL 뒤의 / 가 영향을 미칠 수 있기 때문에 확실하지 않으면 기본 값인 * 로 진행합니다.)\nEnable CORS 버튼을 클릭하여 진행합니다.\n정상적으로 완료되었다면 왼쪽 탭에 OPTIONS 가 추가된 것을 확인할 수 있습니다.\n마지막으로 Actions 메뉴의 Deploy API 버튼을 클릭하여 prod 단계에 배포합니다.\n배포한 Static Page를 웹브라우저에서 열어주거나 API 의 Invoke URL을 브라우저에서 열어주시면 Section 2에서 테스트로 입력했던 데이터가 표시되거나 JSON(직접 Invoke URL을 열었을 경우) 으로 표기 되는 것을 확인 할 수 있습니다.\n이 섹션에서 구성한 웹페이지는 다음과 같이 랭킹 보드를 위한 목적으로 사용될 예정입니다.\n이제 게임을 위한 기반 작업들을 마무리했습니다. :) 본격적으로 게임 서버를 구축할 시간입니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/awsservice/lab13/",
	"title": "SQS 생성하기",
	"tags": [],
	"description": "",
	"content": "SQS 생성하기 이제 SQS 설정을 시작합니다. SQS를 이용하여 게임 결과 처리를 위한 대기열을 만들 것입니다.\n콘솔에서 SQS 메뉴로 들어갑니다. https://console.aws.amazon.com/sqs 대기열 생성을 클릭하여 생성을 시작합니다. Queue 이름은 game-result-queue로 입력하고, 표준 Queue를 선택합니다. 대기열 생성 버튼을 클릭하여 Queue 생성을 완료합니다. Queue 생성이 완료되면 Details에 보이는 endpoint URL을 기록해둡니다. 마찬가지로 뒤의 Lambda 소스 코드에 사용할 예정입니다. 생성된 Queue와 함께 아까 생성된 Dynamo DB, ElastiCache의 동작은 뒤의 Lambda를 통하여 확인하도록 하겠습니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/fleetiq/lab31/",
	"title": "실습 사전 준비",
	"tags": [],
	"description": "",
	"content": "\rFleetIQ 기능 실습은 최소한의 Dependency 로 진행하실 수 있습니다. 다만, 최신 기능인만큼 CLIv2의 설치가 필요합니다.\nCLIv2 설치 FleetIQ 실습을 위해서는 CLI v2 가 필요합니다. 다음 링크로부터 CLI 커맨드를 실행할 환경에서 CLI 버전 2를 설치하도록 합니다. Windows : https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/install-cliv2-windows.html Mac OS : https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/install-cliv2-mac.html Linux : https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/install-cliv2-linux.html 커맨드는 인터넷이 연결되어있는 어떤 환경에서도 실행하실 수 있습니다. 편의성을 위해 CLI 를 실행하는 환경에서 구성하시는 것을 권고드립니다. Cloud9 개발 환경 (선택) Cloud9 은 코드를 작성 및 실행하고 디버깅하기 위한 클라우드 기반 IDE 입니다. 실습에서 사용할 리소스에 대한 개발 환경이 준비되어 있다면, Cloud9 은 사용하지 않으셔도 무방하지만, 본 실습 내용은 개발 환경 통일화와 간소화를 위해 Cloud9 을 기반으로 진행합니다. "
},
{
	"uri": "/aws-gamelift-sample/ko/fleetiq/lab32/",
	"title": "Fiesta IAM 구성",
	"tags": [],
	"description": "",
	"content": "Fiesta 기능 사용을 위한 IAM 구성 독립실행형 FleetIQ 기능 사용을 위해서는 EC2 인스턴스 및 Auto Scaling 기능과 상호작용할 수 있는 제한된 권한을 부여해야합니다.\nIAM 콘솔에 로그인합니다. (https://console.aws.amazon.com/iam)\nIAM 정책 메뉴를 진입한 상태에서 Create Policy 을 선택합니다.\n다음과 같이 JSON 형식으로 정책을 입력할 수 있도록 전환합니다.\n정책의 내용은 다음과 같이 구성합니다.\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;ec2:TerminateInstances\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;ec2:ResourceTag/GameLift\u0026#34;: \u0026#34;GameServerGroups\u0026#34; } } }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;autoscaling:CompleteLifecycleAction\u0026#34;, \u0026#34;autoscaling:ResumeProcesses\u0026#34;, \u0026#34;autoscaling:EnterStandby\u0026#34;, \u0026#34;autoscaling:SetInstanceProtection\u0026#34;, \u0026#34;autoscaling:UpdateAutoScalingGroup\u0026#34;, \u0026#34;autoscaling:SuspendProcesses\u0026#34;, \u0026#34;autoscaling:DetachInstances\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;aws:ResourceTag/GameLift\u0026#34;: \u0026#34;GameServerGroups\u0026#34; } } }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;ec2:DescribeImages\u0026#34;, \u0026#34;ec2:DescribeInstances\u0026#34;, \u0026#34;autoscaling:DescribeAutoScalingGroups\u0026#34;, \u0026#34;ec2:DescribeLaunchTemplateVersions\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;sns:Publish\u0026#34;, \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:sns:*:*:ActivatingLifecycleHookTopic-*\u0026#34;, \u0026#34;arn:aws:sns:*:*:TerminatingLifecycleHookTopic-*\u0026#34; ] } ] } 정책을 구성하고 이름을 FleetIQFiestaPolicy 로 지정합니다. 다음으로 정책을 사용할 IAM 역할을 생성해보도록 하겠습니다. 그림과 같이 EC2 사용 사례로 역할을 시작합니다. 권한 정책으로 좀 전에 만든 FleetIQFiestaPolicy 를 연결합니다. 만들어진 FleetIQFiestaRole 역할에 대해 신뢰 관계를 편집해야 합니다. 기존에는 ec2 기반의 신뢰 정책으로 구성되어있을 것입니다. 신뢰 관계를 다음과 같이 편집합니다. { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: [ \u0026#34;gamelift.amazonaws.com\u0026#34;, \u0026#34;autoscaling.amazonaws.com\u0026#34; ] }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } 위의 Policy Document 는 GameLift 서비스 및 Auto Scaling 서비스로부터 권한을 위임할 수 있는 역할로 구성한다는 의미가 됩니다.\nFiesta 관련 정책 및 역할 설정이 끝났으면, 다음 장에서는 FleetIQ 가 할당할 서버 인스턴스에 대한 설정을 해보겠습니다. "
},
{
	"uri": "/aws-gamelift-sample/ko/fleetiq/",
	"title": "FleetIQ 기반 서버 구성",
	"tags": [],
	"description": "",
	"content": "GameLift 독립형 FleetIQ 기능 사용하기 앞서 실습에서 우리는 GameLift 의 스팟 플릿 구성을 통해 세션 게임 서버들을 배치할 수 있었습니다. 이 기능을 통해 온디맨드 대비 60-80% 의 비용 절감 효과를 얻을 수 있었고, 이는 GameLift 내부에서 FleetIQ 라는 기능을 통해 스팟 인스턴스의 중단률을 낮추어 운용률을 높여주었습니다. FleetIQ 기능이 이제는 독립형으로 제공됩니다. FleetIQ 기능을 통해 낮은 비용의 스팟 인스턴스를 보다 안전하게 사용하면서도 EC2 리소스 및 Auto Scaling Group 을 직접 관리하고, 선택적으로 다른 AWS 와 유연하게 통합할 수 있습니다. 즉, 보다 저렴한 가격으로 개발 및 운영에 있어서 높은 유연성을 가질 수 있습니다!\n그럼 이번 실습을 통해 어떻게 저렴한 컴퓨팅 비용으로 게임 서버를 구성할 수 있는지 간단하게 알아보도록 하겠습니다. 독립 실행형 FleetIQ 는 현재 Preview 로 제공되는 기능이므로, 본 자료는 지속적으로 업데이트될 예정입니다.\nArchitecture Diagram FleetIQ 기능은 GameLift 의 기능으로 포함되어 있지만, 독립적인 아키텍처를 구성합니다.\nFleetIQ 를 이용하는 서버와 클라이언트는 FleetIQ 가 지원되는 SDK 나 CLI, 또는 API 를 이용해서 구현될 수 있습니다. 이는 GameLift 와 독립적인 기능을 이용하며, GameLift 에 종속되지 않습니다. 실습을 통해 어떻게 이용할 수 있는지 알아보겠습니다.\n보다 자세한 FleetIQ 의 구조는 다음 링크를 참고해보실 수 있습니다.\nhttps://docs.aws.amazon.com/ko_kr/gamelift/latest/developerguide/gsg-intro.html\n"
},
{
	"uri": "/aws-gamelift-sample/ko/awsservice/lab14/",
	"title": "IAM 정책 및 역할 생성",
	"tags": [],
	"description": "",
	"content": "IAM 정책 및 역할 생성 1장의 마지막으로, 이번 실습에서 만드는 full stack application에 사용할 IAM 정책(policy)와 역할(role)을 생성합니다\n우선, 역할에 사용될 정책을 만듭니다. 이 랩에서는 편의를 위해서 AWS Managed Policy를 주로 사용합니다. 콘솔에서 IAM 메뉴로 이동합니다. https://console.aws.amazon.com/iam\n메뉴에서 Policies를 선택하고 Create policy 버튼을 클릭합니다.\nVisual editor에서 Service는 GameLift를 선택하고 Actions에서는 랩의 편의상 All GameLift actions를 선택합니다. Review Policy를 클릭하여 다음 단계로 진행합니다.\n정책의 이름(GameLiftFullAccess)을 입력하고 Create policy 버튼을 클릭합니다.\n다음은 후반부 Lamdba 함수에 사용할 5 가지 역할(Role)을 생성할 것입니다.\nIAM 콘솔에서 Role 메뉴로 이동한 뒤 Create role 버튼을 클릭합니다.\nRole type에서 AWS Service Role의 AWS Lambda를 선택합니다.\n이 Role에는 3개의 정책을 할당할 것입니다. 순서대로 AmazonSQSFullAccess, AmazonDynamoDBFullAccess, AWSLambdaBasicExecutionRole 정책을 선택합니다.\nTag는 선택 사항으로 입력합니다. Next: Review를 선택합니다. Role name은 Gomok-game-sqs-process를 입력합니다.\nCreate role 버튼을 클릭하여 첫 번째 역할 생성을 완료합니다.\n두 번째 역할도 첫 번째와 동일한 방법으로 생성합니다. 하지만 이번에는 AmazonDynamoDBFullAccess, AmazonVPCFullAccess, AWSLambdaBasicExecutionRole 정책을 추가합니다.\n두 번째 역할의 이름은 Gomok-game-rank-update로 지정합니다.\n세 번째 Role도 동일한 방법으로 생성합니다. 이번에는 AmazonVPCFullAccess, AWSLambdaBasicExecutionRole 정책을 추가해줍니다.\n세 번째 역할의 이름은 Gomok-game-rank-reader로 지정합니다.\n네 번째 역할도 첫번째와 동일한 방법으로 생성합니다. 이번에는 AWSLambdaBasicExecutionRole, AmazonDynamoDBFullAccess, 그리고 앞에서 생성한 GameLiftFullAccess 정책을 추가해 줍니다.\n네 번째 역할의 이름은 Gomok-game-match-request로 지정합니다.\n마지막으로 다섯 번째 역할도 동일한 방법으로 생성합니다. 이번에는 AWSLambdaBasicExecutionRole과 앞에서 생성한 GameLiftFullAccess 정책을 추가해 줍니다.\n다섯 번째 역할의 이름은 Gomok-game-match-status로 지정합니다.\n모두 생성이 완료되었다면 다음 스크린 캡처와 같이 다섯개의 역할을 확인할 수 있습니다.\n마지막으로 하나의 역할을 더 생성합니다. 앞서는 Lambda가 사용할 역할을 생성하였지만, 이번에는 GameLift에서 생성하는 Fleet에서 사용할 역할을 생성합니다. GameLift의 Fleet에서는 Game의 결과를 SQS에 전송할 때 사용하는 권한이 필요합니다.\nCreate Role을 선택하여 새로운 역할을 생성합니다. 이 역할의 사용은 GameLift 서비스가 수행하므로 GameLift를 서비스를 선택해야 하지만, 콘솔 환경에 따라 해당 Use case 에 대해 우리가 사용하고자하는 정책을 할당하지 못할 수 있습니다. 따라서 EC2 를 선택하고 다음으로 이동합니다.\n이 역할이 필요한 권한은 AmazonSQSFullAccess를 선택하고 역할 이름은 Gomoku-GameLiftFleetRole로 입력합니다.\n이 역할을 사용할 수 있는 서비스를 GameLift로 변경해야 합니다. 앞서 생성한 역할을 선택하여 Trust relationships 탭을 선택하고, Edit trust relationship 버튼을 클릭합니다. 아래와 같이 ec2로 되어 있던 부분을 gamelift로 변경하고 update trust policy 버튼을 클릭하여 저장합니다. 여기까지가 1장 실습의 내용입니다. :) 다음 장에서는 본격적으로 게임에 들어가는 로직을 구현해보겠습니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/flexmatch/lab24/",
	"title": "게임 서버 빌드 &amp; 플릿 생성",
	"tags": [],
	"description": "",
	"content": "GameLift 서비스와 함께 게임 서버 구축 이번에는 FlexMatch 를 이용하는 서버리스 기반의 서버 바이너리를 Gamelift 서비스와 함께 동작하도록 구성하는 작업을 시작하겠습니다. 마찬가지로 서버 바이너리는 컴파일 된 형태로 제공되었기 때문에 추가 작업이 필요하지는 않으며 직접 컴파일하여 생성한 바이너리를 소스 코드로 사용하실 수도 있습니다.\nFlexMatch 기능을 서버 또는 클라이언트에 구현하면 별도의 매치메이커 서버 없이도 매칭 기능을 이용하실 수 있습니다. 기능을 위해 FlexMatch 기반의 바이너리는 실습을 위해 제공된 바이너리 루트 폴더에 bin/FlexMatch 하위의 GomokuServer 폴더를 사용합니다\n이번 실습에는 이미 컴파일된 파일이 준비되어 있지만, 직접 컴파일 하고 싶으실 경우 Appendix 를 참조할 수 있습니다.\n제공된 소스코드의 루트 폴더에서 bin/GomokuServer 폴더를 확인하시면 GomokuServer.exe, aws-cpp-sdk-*.dll, config.ini, install.bat, aws-cpp-sdk-gamelift-server.dll 등 파일을 확인하실 수 있습니다.\n워크샵은 윈도우 서버 환경에서 vc_redist.x86.exe 파일의 설치를 요구합니다. 다음 링크를 통해 vc_redist.x86.exe 파일을 게임 서버 루트 경로에 위치시킵니다. 혹은 다음 링크를 통해 동작하는 Deployment 버전을 다운로드받으실 수도 있습니다.\n텍스트 편집기를 통하여 config.ini 파일을 수정합니다. SQS_REGION는 SQS를 생성한 Region입니다. (예: ap-northeast-2). SQS_ENDPOINT 에는 게임 결과를 처리할 SQS의 Endpoint를 입력합니다. config.ini 는 사전 준비에서 다운받으신 바이너리의 다음 경로에 위치합니다. (deploy/bin/FlexMatch/GomokuServer/Binaries/Win64/config.ini) ROLE_ARN은 섹션1에서 마지막으로 만들었던 GameLift Fleet을 위한 ROLE_ARN을 입력합니다. (아래의 스크린샷 처럼 따옴표 없이 입력해주세요. Role Arn은 Fleet 내부의 인스턴스에서 얻어 올 수도 있으나 현재 데모에서는 명시적으로 구성해 줍니다.) Gamelift는업로드의 복잡성 때문에 현재 CLI를 통한 업로드 만을 지원합니다. AWS CLI 환경이 구성되어 있지 않다면 HoL 사전준비 를 참고해서 구성해줍니다.\nGomokuServer 폴더에서 다음의 GameLift 업로드 명령어를 통해 빌드를 업로드 합니다. (GomokuServer 폴더의 위치는 deploy/bin/FlexMatch/GomokuServer/ 입니다. GomokuServer 폴더 하위에는 Binaries 폴더와 install.bat 파일이 존재합니다)\naws gamelift upload-build --name \u0026#34;GomokuServer-Build-1\u0026#34; --build-version \u0026#34;1.0.0\u0026#34; --build-root . --region \u0026lt;Your Lab Region\u0026gt; 업로드할 때 실습 Region을 올바르게 설정하였는지 확인해야 합니다.\n진행하는 중 콘솔의 GameLift 서비스로 가면 빌드가 업로드 되는 것을 확인할 수 있습니다. (https://console.aws.amazon.com/gamelift)\n콘솔의 빌드 페이지에서 방금 업로드한 빌드를 선택합니다. Create fleet from build 버튼을 클릭합니다. 이를 통해 게임 서버의 fleet을 생성하게 됩니다.\n다음의 정보를 입력합니다. 언급이 없는 부분은 기본값으로 진행합니다. Name: GomokuGameServerFleet-1 Instance Type: C5.large Fleet type: Spot Instance Role ARN: 섹션1의 마지막에서 GameLift Fleet을 위해 만들었던 Role의 ARN (Gomoku-GameLiftFleetRole) 게임 실행 설정 (녹색 체크 버튼 확인)\nLaunch path: Binaries\\Win64\\GomokuServer.exe (직접 컴파일 했다면 컴파일한 바이너리명) Concurrency Process : 50 네트워크 설정 (녹색 체크 버튼 확인)\nEC2 Port Setting : 49152-60000 Protocol : TCP IP address range : 0.0.0.0/0 Fleet Type 을 Spot 으로 지정함으로써 GameLift 내에서 저렴한 가격으로 게임 서버 인스턴스를 호스팅하실 수 있습니다.\n생성이 완료되면 상태창의 파란색 박스가 Active 상태의 녹색으로 변하며, 시간은 20분 정도 소요됩니다. 위의 그림은 서로 다른 버전으로 빌드된 예시이며 이해를 돕고자 추가된 그림입니다. 실습 환경에서는 똑같지 않을 수 있습니다.\nFleet 이 생성되는 동안 Alias 를 생성해보겠습니다.\n메뉴에서 Create alias 옵션을 선택합니다. 그리고 Alias name과 Description을 입력해줍니다.\nRouting options의 Type은 Simple을 선택하고, Associated fleet에서 [Select fleet]을 선택한 뒤 생성한 fleet을 선택합니다\n플릿이 아직 생성되지 않은 상태여도 선택이 가능합니다. Alias 가 호출될 시 해당 호출은 연결된 플릿으로 전달됩니다.\n실제로 GameLift Fleet 을 이용할 때에는 Alias ID 를 사용하게 됩니다. Alias 가 생성되면 해당 Alias ID 를 기억해둡니다. 기본적으로 240분 동안 아무 활동이 없다면 Fleet은 인스턴스 0개로 스케일-인 합니다. 이번 실습을 진행하는 동안에는 문제가 없지만 조금 더 오래 실행하고 싶다면 auto scale parameter를 최소한 1로 변경해야 합니다. 아니면 직접 1개의 인스턴스를 실행하도록 override해주어야 합니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/gamelift/lab44/",
	"title": "게임 서버 빌드 &amp; 플릿 생성",
	"tags": [],
	"description": "",
	"content": "GameLift 서비스와 함께 게임 서버 구축 이제 서버 바이너리를 Gamelift 서비스와 함께 동작하도록 구성하는 작업을 시작하겠습니다.\n이번 실습에는 이미 컴파일된 서버 바이너리가 준비되어 있지만, 직접 컴파일 하고 싶으실 경우 Appendix 를 참조할 수 있습니다.\n제공된 소스코드 또는 바이너리의 루트 폴더에서 bin/Classic/server 폴더를 확인하시면 GomokuServer.exe, aws-cpp-sdk-*.dll, config.ini, install.bat, aws-cpp-sdk-gamelift-server.dll 등 파일을 확인하실 수 있습니다. 그중에서도 vc_redist.x86.exe 파일이 있는지 확인합니다. 실습을 위해 사용된 바이너리는 Visual Studio 환경에서 제작되었으므로 배포용 환경 구성을 위해 필요합니다.\n텍스트 편집기를 통하여 config.ini 파일을 수정합니다. SQS_REGION 는 SQS를 생성한 Region입니다. (예: ap-northeast-2). SQS_ENDPOINT 에는 SQS의 Endpoint를 입력합니다. SQS_ACCESSKEY 와 SQS_SECRETKEY 에 IAM 사용자의 AccessKey 와 Secret AccessKey 를 입력합니다. (AccessKey 와 SecretAccessKey 를 전달하도록 구성하는 것은 단지 실습의 편의성을 위함입니다. 실제 계정을 사용하신다면 설정이 외부에 노출되지 않도록 유의합니다.)\n본 실습의 바이너리는 IAM 역할이 지원되기 이전에 만들어졌으며, 실습의 편의를 위해 Credential 을 전달합니다. 현재는 Credential 을 직접 전달할 필요가 없으며, Best Practice 는 IAM Role 을 사용하는 것입니다. 관련 내용은 FlexMatch 실습을 통해 참고해보실 수 있습니다.\n만약 Mac 이나 Windows 환경에서 파일을 작업하고, 별도의 윈도우로 배포하고 계시다면 텍스트 파일 포맷에 유의합니다. 특히 윈도우에서의 New Line 포맷은 CRLF 로 차이가 있고, 이는 설정 내용 파싱에 영향을 줄 수 있습니다.\nCLI 를 이용해 GameLift 바이너리를 빌드합니다. 현재 GameLift 는 업로드의 복잡성으로 인해 CLI 를 통한 업로드를 지원합니다. CLI 환경이 구성되어 있지 않다면 (0-2. 실습 사전 준비 파트)를 참고합니다. 빌드의 경로와 설정하게될 GameLift 콘솔에서 실행파일(exe)의 경로가 일치해야하므로, GomokuServer.exe 바이너리를 포함한 경로에서 명령어를 실행하시는 것을 추천합니다. aws gamelift upload-build --name \u0026#34;Classic_Build-1\u0026#34; --build-version \u0026#34;0.0.1\u0026#34; --build-root . --region us-east-1 업로드할 때 실습 Region 을 올바르게 설정했는지 확인합니다.\n진행하는 중 콘솔의 GameLift 서비스로 가면 빌드가 업로드 되는 것을 확인할 수 있습니다. https://console.aws.amazon.com/gamelift\n빌드가 성공하면 위의 그림처럼 활성화됩니다. 성공한 빌드로부터 Fleet 을 생성해봅시다. 다음과 같이 설정값을 입력해줍니다. 플릿 유형에서 스팟 타입을 선택하시면, 스팟 플릿 형태로 GameLift 인스턴스 플릿을 구성하실 수 있습니다. GameLift 는 중단 확률이 가장 낮은 인스턴스 유형에 스팟 인스턴스를 배치하여 중단률 및 비용이 가장 낮은 플릿을 선택합니다. 이 기능을 통해 매우 비용 효율적으로 GameLift 서비스를 이용하실 수 있습니다.\nName: GomokuGameServerFleet-1 Instance type: c3.large or c4.large Launch path: GomokuServer.exe Concurrent processes: 50 EC2 Port settings Port range: 49152-60000 Protocol: TCP IP address range: 0.0.0.0/0 설정이 완료되면 Initialize Fleet 을 통해 플릿을 생성합니다. 작업은 20분정도 시간이 소요됩니다.\n완료된 플릿은 위와 같은 상태로 바뀌어야 합니다. 플릿이 생성되는 동안 Alias 를 구성해보겠습니다.\nGameLift 메뉴를 열고 별칭 생성 메뉴를 클릭합니다. 적합한 별칭을 지정하고, 라우팅 유형을 Simple 로 선택해줍니다. 다음과 같이 Alias 에 생성 중인 Fleet 을 연결해줍니다. 이제 Fleet 에 접근하기 위해 Alias 를 사용할 것입니다. 별칭 ID 를 기록해둡니다. 다음으로 매치메이킹 서버를 구성해보겠습니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/gamelift/",
	"title": "GameLift Classic 실습 (옵션)",
	"tags": [],
	"description": "",
	"content": "\r이번 Lab 은 FlexMatch 기능이나 FleetIQ 기능과 무관하게 GameLift 의 기능만을 순수하게 이용해서 오목 게임을 구현해봅니다. 일부 리전에서 아직 FlexMatch 기능이 제공되지 않는 경우, 본 실습 과정이 GameLift 시작에 유용하게 사용되어질 수 있습니다.\n실습 목차 1. 게임 결과 데이터 처리를 위한 Lambda 함수 작성 2. 랭킹 보드 구성을 위한 API Gateway 작성 3. S3 기반의 랭킹 보드 웹 페이지 만들기 4. 게임 서버 빌드 및 플릿 생성4 5. 매치메이킹을 위한 EC2 인스턴스 생성 6. 게임 클라이언트 구성하고 세션 게임에 연결\nArchitecture Diagram FlexMatch 기반의 아키텍처와 차이점은 매치메이킹을 위한 별도의 인스턴스를 구성한다는 점입니다. 이 부분에 중점을 두어 실습을 진행합니다. 나머지 과정에 큰 차이는 없습니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/flexmatch/lab25/",
	"title": "Serverless FlexMatch 구성하기",
	"tags": [],
	"description": "",
	"content": "Serverless 기반의 FlexMatch 기능 이용하기 본 실습에서는 다양한 구현 아키텍처를 보여주기 위하여 FlexMatch 기능은 서버리스 매치메이킹을 이용합니다.\nFlexMatch 를 이용하면, 별도의 매치메이커 서버를 구현할 필요 없이 세션 매칭 기능을 이용하실 수 있습니다. 기능을 이용하기 위해서는 서버 또는 클라이언트 레벨에서 FlexMatch API 또는 SDK 의 호출이 필요하며, 이번 실습에서는 이를 위해 Lambda 함수를 사용합니다.\nGameLift Queue 설정 FlexMatch 를 사용하기 위해서는 GameLift 의 Queue 서비스를 사용해야 합니다.\n메뉴에서 Create a queue 를 선택합니다. 아래와 같이 Queue 의 이름을 입력하고, Add destination 에서 앞서 생성한 Alias 를 선택합니다. Create queue 를 선택하여 queue 를 생성합니다. 다음 단계를 FlexMatch 를 위한 rule 을 만듭니다. Create matchmaking rule set 을 선택합니다.\n아래와 같이 Rule set 의 이름을 입력하고 Rule set 을 넣어 줍니다. Rule set 은 제공된 프로젝트의 루트폴더에서 Ruleset 폴더 하위의 GomokuRuleSet.json 의 파일 내용을 복제하여 넣어 줍니다.\n{ \u0026#34;ruleLanguageVersion\u0026#34; : \u0026#34;1.0\u0026#34;, \u0026#34;playerAttributes\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;score\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;number\u0026#34;, \u0026#34;default\u0026#34; : 1000 } ], \u0026#34;teams\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;blue\u0026#34;, \u0026#34;maxPlayers\u0026#34; : 1, \u0026#34;minPlayers\u0026#34; : 1 }, { \u0026#34;name\u0026#34; : \u0026#34;red\u0026#34;, \u0026#34;maxPlayers\u0026#34; : 1, \u0026#34;minPlayers\u0026#34; : 1 } ], \u0026#34;rules\u0026#34; : [ { \u0026#34;name\u0026#34;: \u0026#34;EqualTeamSizes\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;comparison\u0026#34;, \u0026#34;measurements\u0026#34;: [ \u0026#34;count(teams[red].players)\u0026#34; ], \u0026#34;referenceValue\u0026#34;: \u0026#34;count(teams[blue].players)\u0026#34;, \u0026#34;operation\u0026#34;: \u0026#34;=\u0026#34; }, { \u0026#34;name\u0026#34; : \u0026#34;FairTeamSkill\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;distance\u0026#34;, \u0026#34;measurements\u0026#34; : [ \u0026#34;avg(teams[*].players.attributes[score])\u0026#34; ], \u0026#34;referenceValue\u0026#34; : \u0026#34;avg(flatten(teams[*].players.attributes[score]))\u0026#34;, \u0026#34;maxDistance\u0026#34; : 300 } ], \u0026#34;expansions\u0026#34; : [ { \u0026#34;target\u0026#34; : \u0026#34;rules[FairTeamSkill].maxDistance\u0026#34;, \u0026#34;steps\u0026#34; : [ { \u0026#34;waitTimeSeconds\u0026#34; : 10, \u0026#34;value\u0026#34; : 500 }, { \u0026#34;waitTimeSeconds\u0026#34; : 20, \u0026#34;value\u0026#34; : 800 }, { \u0026#34;waitTimeSeconds\u0026#34; : 30, \u0026#34;value\u0026#34; : 1000 } ] } ] } 여기서의 rule 은 간단하게 score 점수가 300 점 이내의 사용자간에 Match 를 시켜주며 해당 사용자 match 가 시간내에 안 될 경우, rule 을 완화하여 match 시켜 줍니다. Validate rule set 을 선택하여 rule set 이 정상인지 확인 한 후에 create rule set 으로 rule set 을 생성합니다.\n다음은 앞서 만든 Queue 와 Matchmaking rule set 을 연결 시켜 주는 작업을 수행합니다. Create matchmaking configuration 을 메뉴에서 선택합니다. 아래와 같이 앞서 만든 queue 와 rule set 을 선택하여 configuration 을 생성합니다. 리전 및 대기열 선택을 확인합니다. Lambda 함수 구성 CloudFormation 스택을 배포하셨다면, 이미 Lambda 함수의 기본 틀은 마련되어 있습니다. 단계를 진행해보시면서 필요한 부분만 채워주시면 됩니다.\n이제 GameLift 의 FlexMatch 설정은 완료하였습니다. 다음은 game client 가 FlexMatch 요청을 하는 Lambda 와 API Gateway 를 구성합니다. 이번 랩에서는 총 2개의 Lambda 함수를 생성할 것입니다. 하나는 client로부터 MatchMaking 요청을 처리하는 람다함수이고, 다른 하나는 MatchMaking 결과를 확인하기 위한 요청을 처리하는 람다입니다. 첫번째로 Matchmaking 요청을 처리하는 람다를 생성합니다.\n앞서 과정에서 해봤다면, 어렵지 않을 것입니다!\n콘솔에서 Lambda 메뉴로 이동합니다. https://console.aws.amazon.com/lambda\nCreate function 버튼을 클릭하여 첫번째 함수 생성을 시작합니다.\nAuthor from scratch 메뉴를 선택하여 빈 함수를 우선 생성합니다.\nName 항목에는 game-match-request를 입력합니다.\nRuntime은 Python 3.9을 선택합니다.\nPermissions 항목에서 Role 은 Use an existing role을 선택하고 기존에 만들어둔 Gomok-game-match-request를 선택하고 Create function을 실행합니다.\n제공된 소스 파일 중 Lambda 폴더 밑에 있는 MatchRequest.py의 내용을 Lambda 코드창에 복제해 넣습니다. 코드 상의 Region과 Match Config의 이름이 앞서 생성한 이름과 동일한지 확인합니다. (대소문자 일치하도록 확인) 아울러 핸들러로 지칭하는 함수와 소스 코드의 함수명이 일치하는지 확인합니다.\n기본 설정에서 Lambda 함수의 실행 시간 및 메모리 설정을 합니다. Memory : 128MB Timeout : 1 min Lambda 함수의 핸들러 설정을 잘 체크해줍니다. Lambda 함수가 실행되면 해당 핸들러가 실행됩니다.\nSave 버튼을 클릭하여 함수를 생성합니다. 생성한 함수는 game client 의 Matchmaking 요청을 받아 DynamoDB 에서 사용자의 정보를 읽고 이에 기반하여 GameLift 에 match making 을 요청합니다.\nCreate function 버튼을 클릭하여 두번째 함수 생성을 시작합니다.\nAuthor from scratch 메뉴를 선택하여 빈 함수를 우선 생성합니다.\nName 항목에는 game-match-status를 입력하고 Runtime 으로 Python 3.9 을 선택합니다.\nPermissions 항목에서 Role 은 Use an existing role을 선택하고 기존에 만들어둔 Gomok-game-match-status를 선택하고 Create function을 실행합니다.\n제공된 소스 파일 중 Lambda 폴더 밑에 있는 MatchStatus.py 의 내용을 Lambda 코드창에 복제해 넣습니다.\n앞서와 같이 Lambda 함수 실행시간을 1 분으로 조정합니다.\nSave 버튼을 클릭하여 함수를 생성합니다. 생성한 함수는 game client 가 TicketId 로 자신이 요청한 match making 요청이 완료되었는지를 확인하고 요청이 완료되었다면 client 가 접근할 게임서버의 IP 주소와 Port 를 알려 줍니다\nAPI Gateway 구성 다음은 앞서 생성한 Lambda 함수를 game client 가 호출할 수 있도록 API Gateway 를 설정합니다.\n우선 콘솔에서 API Gateway 메뉴로 이동합니다. (https://console.aws.amazon.com/apigateway)\n앞서 생성한 API Gateway를 선택하고 Create Resource를 선택합니다.\nResource name은 matchrequest를 입력하고 Enable API Gateway CORS를 체크 하고 Create Resource 버튼을 클릭하여 Resource를 생성합니다. 생성한 Resource에 새로운 Method를 생성합니다. Actions 버튼을 클릭한 뒤 Create Method 메뉴를 선택하고, POST 메서드에 대한 API 를 구성합니다.\nPOST 메소드의 상세 설정에서 Integration type은 Lambda Function을 선택하고 Lambda Region에 실습을 진행 중인 Region을 선택합니다. Lambda Function에는 앞서 생성한 game-match-request를 선택한 뒤 Save 버튼을 클릭합니다\n두 번째 람다함수를 연동하기 위해 생성한 API 에 두 번째 Resource 를 만듭니다. API 의 root 를 선택하고 Actions 에서 Create Resource 를 선택합니다.\n앞선 두 번의 API 생성과 동일한 방식으로 생성합니다. Resource Name 은 matchstatus 로 입력합니다. Enable API Gateway CORS 를 체크합니다.\nPOST 메소드를 생성하고 game-match-status 람다 함수를 연동하고 Save 버튼을 클릭하여 저장합니다.\nFlexMatch 를 위한 Lambda 함수들이 모두 구성되었습니다. 이제 API 에 대한 배포를 수행합니다. Actions 버튼을 클릭하고 Deploy API 메뉴를 클릭합니다.\n완료되면 API의 Invoke URL이 표시됩니다. 아래 URL은 game client 설정에 사용됩니다. "
},
{
	"uri": "/aws-gamelift-sample/ko/fleetiq/lab33/",
	"title": "게임 서버 그룹 만들기",
	"tags": [],
	"description": "",
	"content": "FleetIQ 는 게임 서버 그룹이라는 추상화된 게임 호스팅 계층을 만들고, 이를 Auto Scaling Group 과 연동합니다. 게임 서버 리소스는 FleetIQ 에 등록되고 게임 서버 그룹 내에서 관리됩니다. FleetIQ 에서 게임 서버 그룹을 생성하면 Auto Scaling Group 이 생성되며, Auto Scaling Group 내에서 할당할 컴퓨팅 리소스가 시작됩니다. 그렇기 때문에 컴퓨팅 리소스를 최적화하기 위하여 적절한 인스턴스 타입으로 구성된 게임 서버 그룹을 할당하는 것이 중요합니다. FleetIQ 는 예측 알고리즘에 기반하여 게임 서버 그룹 목록의 각 스팟 인스턴스 유형을 정기적으로 평가하여, 게임 호스팅에 대한 실행 가능성을 계산합니다.\nFleetIQ 인스턴스에서 사용할 IAM 역할 만들기 IAM 콘솔에 접속합니다. (https://console.aws.amazon.com/iam/home?)\n좌측 메뉴에서 역할을 선택하고 EC2 사용 사례로 새로운 역할을 생성합니다.\n권한 정책을 연결합니다. GameLift 로 검색하시면 관리형 정책인 GameLiftGameServerGroupPolicy 가 나타납니다. 앞서 실습을 진행하셨다면, 다음과 같이 GameLiftFullAccess 역할이 같이 포함되어 있습니다.\n두 정책을 선택하여 역할을 만들고 이름을 GameLiftFleetIQRole 으로 지정합니다. EC2 Launch Template 작성하기 EC2 콘솔에 접속합니다. (https://console.aws.amazon.com/ec2/v2/home)\n좌측 메뉴에서 시작 템플릿을 클릭하고, 새로운 시작 템플릿을 생성해줍니다.\n다음과 같이 템플릿을 구성합니다.\n이전까지 Windows 기반의 실습을 진행했다면, 본 실습에서는 Linux 기반의 게임 서버를 구성할 예정이므로, Amazon Linux2 AMI 를 선택해줍니다. 로그인이 가능하도록 키-페어의 설정도 같이 해줍니다.\n기본 VPC 에서 LaunchTemplate 을 만들도록 합니다. VPC 설정 및 Security Group을 알맞게 구성하도록 합니다. 별도의 제약은 없지만, 서버와 클라이언트는 TCP 로 통신할 예정이므로, TCP 프로토콜에 적절한 인바운드 구성을 할 수 있도록 Security Group 을 구성합니다. IAM 인스턴스 프로파일에서 바로 전 단계에서 구성한 GameLiftFleetIQRole 을 선택합니다.\n마지막으로 사용자 데이터에 다음을 입력합니다.\n#!/bin/bash sudo yum install python3 -y sudo pip3 install boto3 sudo pip3 install requests sudo yum install -y gcc-c++ make curl -sL https://rpm.nodesource.com/setup_12.x | sudo -E bash sudo yum install -y nodejs 위의 사용자 데이터 코드는 게임 서버가 생성되면 원격으로 Cloud9 IDE 를 연결하기 위한 작업을 나타냅니다.\nGame Server Group 생성하기 다음으로 Game Server Group 을 생성해봅니다. AWS CLIv2 가 설치된 환경에서 CLI 커맨드를 통해 이용하실 수 있습니다.\n다음과 같이 커맨드를 입력합니다. aws gamelift create-game-server-group --game-server-group-name GameServerGroups --role-arn \u0026lt;FleetIQFiestaRole 의 arn\u0026gt; --min-size 1 --max-size 2 --launch-template LaunchTemplateId=\u0026lt;LaunchTemplate ID\u0026gt; --instance-definitions \u0026#39;[{\u0026#34;InstanceType\u0026#34;: \u0026#34;c5.large\u0026#34;}, {\u0026#34;InstanceType\u0026#34;: \u0026#34;m5.large\u0026#34;}]\u0026#39; --region ap-northeast-2 위의 \u0026lt;\u0026gt; 괄호친 부분에 앞서 생성한 리소스들의 정보를 포함시켜야 합니다. 실습하고자하는 리전을 알맞게 입력했는지 확인합니다.\nCreateServerGroup 이 성공하면 다음과 같이 GameLift 콘솔에서 게임 서버 그룹을 확인해보실 수 있습니다. 게임 서버 그룹의 생성이 지나치게 지연된다면 권한을 확인해보시는 것이 좋습니다.\nAuto Scaling Group 구성이 된 모습도 확인해보실 수 있습니다. EC2 콘솔에서 인스턴스가 자동으로 생성된 부분도 확인해보실 수 있습니다. 게임 서버 그룹내에 가용한 게임 서버들입니다. 하지만 아직 해당 게임 서버들을 통해 FleetIQ 기능을 사용해보실 수는 없습니다. FleetIQ 기능의 사용을 위해서는 FleetIQ 의 Lifecycle 을 구성해주셔야 합니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/gamelift/lab45/",
	"title": "매치메이커 서버 만들기",
	"tags": [],
	"description": "",
	"content": "매치메이킹을 위한 서버 구축 이 단원의 내용은 FlexMatch 를 활용한 경우와 차이가 있습니다. FlexMatch 는 직접 매치메이커를 만들 필요 없이 GameLift 에서 제공하는 자체 매치메이킹을 이용합니다. FlexMatch를 활용한 실습을 원한다면 2단원 실습을 해보실 수 있습니다.\n실제 게임 세션을 처리하고 로직을 작동시킬 게임 서버가 Fleet 위에 배포되고 있다면, 해당 서버에 적절하게 TCP 연결을 맺어줄 매치메이커가 필요합니다. 일반적으로 세션 기반 게임은 매치메이킹을 위한 서버는 별도의 인스턴스가 담당하고, 해당 서버가 세션을 게임 서버에 분산해주는 방식으로 구현됩니다.\n실습을 위해서는 Binary 형태로 구성된 매치메이커 서버(Matchmaker.exe)를 이용하거나, 직접 루트 폴더의 GomokuMatchMaker 프로젝트를 Visual Studio 에서 빌드합니다.\n실행 파일(.exe) 과 같이 포함된 config.ini 파일을 수정합니다. 위와 같이 좀 전에 생성한 Alias 를 지정하고, 포트 설정과 서비스 리전을 알맞게 구성해줍니다. 사용자 정보가 포함된 DynamoDB 테이블 이름도 구성해줍니다.\n다음으로 매치메이커가 구성될 EC2 서버를 위한 IAM Role 을 생성해야 합니다. EC2 IAM Role 을 생성하고, DynamoDB 와 GameLift 에 대한 접근 제어 정책을 부여합니다.\n매치메이커 역할을 담당할 EC2 서버를 구성합니다. Windows 2016 기반의 인스턴스를 구성합니다. 본 바이너리는 2016 기반에서 작성되고 테스트되었습니다. config.ini 에 명시했던 포트(기본값 5999)를 허용하는 Security Group 을 할당합니다. 해당 정책은 TCP 트래픽에 대해 허용되어야 합니다. 위의 단계에서 생성한 IAM Role 을 인스턴스에 부여합니다. 해당 인스턴스에 접속하고, Matchmaker 바이너리를 복사합니다. vc_redist_x64.exe 를 최초 1회 실행하여, C++ 실행 환경을 미리 구성합니다.\n환경이 구성되었으면 GomokuMatchMaker.exe 를 실행시켜 매치메이커를 작동시킵니다.\n마지막으로 매치메이커 서버에 접속할 수 있도록 Elastic IP(EIP) 주소를 할당하고 인스턴스에 부여합니다. GomokuClient 가 해당 IP 주소로 매치메이커 서버에 연결할 것입니다!\n"
},
{
	"uri": "/aws-gamelift-sample/ko/cleanup/",
	"title": "Clean Up",
	"tags": [],
	"description": "",
	"content": "\r실습 과정 동안 고생하셨습니다..! 이제는 리소스들을 정리할 차례입니다.\nCloudFormation Clean Up CloudFormation 을 통해 리소스를 할당했다면, 스택을 삭제해서 쉽게 자동 구성된 리소스들을 삭제하실 수 있습니다.\n이 때, 실습 과정에서 생성한 리소스에 Dependency 가 생겼다면 해당 Dependency 를 제거해주시거나 직접 해당 리소스를 제거해주셔야 합니다.\n리소스 제거 콘솔에서 다음 리소스들을 제거해줍니다.\nGameLift 빌드, 플릿 및 별칭 구성 GameLift 대기열, 매치메이킹 구성 매치메이킹 서버를 위한 EC2 인스턴스 유저 정보 처리를 위한 DynamoDB, ElastiCache, S3 Lambda 함수 API Gateway FleetIQ 실습을 위한 리소스 FleetIQ 리소스 제거 FleetIQ 의 리소스 제거를 위해 CLIv2 환경이 설치된 위치에서 다음 커맨드를 실행합니다.\naws gamelift delete-game-server-group --game-server-group-name \u0026lt;게임 서버 그룹 이름\u0026gt; "
},
{
	"uri": "/aws-gamelift-sample/ko/fleetiq/lab34/",
	"title": "FleetIQ 기반 서버 생성",
	"tags": [],
	"description": "",
	"content": "FleetIQ 서버 개발 환경 구축 FleetIQ 서버 - 클라이언트 기능은 GameLift 에 종속되지않는 독립형 기능입니다. 현재 CLI 및 SDK 형태로 구현을 제공하고 있고, 본 실습에서는 Python 기반의 TCP 통신을 구현해보도록 하겠습니다. 간단하면서도 직접 FleetIQ 의 동작 원리를 이해하고 서버 - 클라이언트 구조를 생성해볼 수 있는 좋은 예제입니다.\nCloud9 콘솔로 접속합니다. (https://console.aws.amazon.com/cloud9/home)\n다음과 같이 새 IDE 를 만듭니다. 이 IDE 를 통해 원격 게임 서버의 코드를 편집할 것 입니다.\n연결 구성을 SSH 로 설정하고, 방금 전에 만든 게임 서버 그룹의 게임 서버 인스턴스의 엔드포인트를 연결합니다. 이 때, 아래쪽의 SSH 키를 복사해서 연결해주어야 합니다. SSH 키를 카피 하셨다면, 다시 EC2 콘솔로 이동하고, 다음과 같이 해당 인스턴스에 접속합니다. 접속에 대한 상세한 가이드는 다음 링크를 참고합니다.\nvi ~/.ssh/authorized_keys 커맨드를 입력하고, 나오는 인증키 정보 창에서 맨 뒤에 복사한 값을 붙여넣기 합니다.\nssh-rsa ~~~ key ssh-rsa @@@ xxx@amazon.com 과 같은 형태로 텍스트 파일이 구성되게 됩니다.\n쉽게 구성하시기 위해서는 vi 기준으로 A 를 입력하시면 파일의 맨 끝으로 이동합니다. 엔터키를 치신 후 붙여넣기하고 저장합니다.\n서버 인스턴스의 콘솔에서 다음 스크립트를 입력합니다. curl -L https://raw.githubusercontent.com/c9/install/master/install.sh | bash 위의 스크립트를 통해 간편하게 EC2 인스턴스에 Cloud9 이 설치됩니다.\n다시 Cloud9 콘솔로 돌아와서 구성을 완료합니다. 다음과 같이 IDE 가 바로 구성되어야 합니다. 서버 사이드 스크립트 작성 Cloud9 환경에 server.py 파일을 생성하고, 다음 서버 스크립트를 복사하여 붙여넣습니다. 이 내부 코드를 하나하나 수정해볼 것입니다. import socket import boto3 import requests GameServerGroupName = \u0026#39;GameServerGroups\u0026#39; GameServerId = \u0026#39;game-server-1\u0026#39; InstanceId = requests.get(\u0026#39;http://169.254.169.254/latest/meta-data/instance-id\u0026#39;).text ConnectionInfo = requests.get(\u0026#39;http://169.254.169.254/latest/meta-data/public-hostname\u0026#39;).text client = boto3.client(\u0026#39;gamelift\u0026#39;, \u0026#39;ap-northeast-2\u0026#39;) server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.bind((\u0026#34;\u0026#34;, 5000)) server_socket.listen(5) def list_game_servers(): pass # Register GameServer def register_game_server(): pass # # Update GameServer def update_game_server(flag): pass # # Deregister GameServer def deregister_game_server(): pass # print(\u0026#34;TCP server waiting for Client on port 5000\u0026#34;) while True: # List Game Server listResponse = list_game_servers() if not \u0026#39;GameServers\u0026#39; in listResponse or not any(server[\u0026#39;GameServerId\u0026#39;] == GameServerId for server in listResponse[\u0026#39;GameServers\u0026#39;]): # Register Game Server to Game Server Group register_game_server() # # Update Game Server Status \u0026#34;AVAILABLE\u0026#34; update_game_server(True) # client_socket, address = server_socket.accept() print(\u0026#34;I got connection from \u0026#34;, address) # Update Game Server Status \u0026#34;UTILIZED\u0026#34; update_game_server(False) # while True: data = client_socket.recv(512).decode() print(\u0026#34;RECEIVED:\u0026#34;, data) if(data == \u0026#39;q\u0026#39; or data == \u0026#39;Q\u0026#39;): client_socket.close() break else: client_socket.send(data.encode()) # Deregister Game Server deregister_game_server() # server_socket.close() print(\u0026#34;SOCKET Closed... End\u0026#34;) 먼저 위의 코드에서 리전을 실습을 진행하는 리전으로 변경해줍니다. 그리고 맨 위의 GameServerGroupName 을 앞서 구성하신 게임 서버 그룹 이름으로 변경합니다. GameServerId는 임의로 유니크하게 지정해줍니다\n비어있는 각 함수 코드들에 내용을 채워넣습니다. 먼저 list_game_servers 함수입니다. def list_game_servers(): response = client.list_game_servers( GameServerGroupName=GameServerGroupName ) print(response) return response 이 함수는 현재 가용한 게임 서버 그룹 내의 게임 서버들을 확인합니다. 비어있다면 새로 등록해줘야 합니다.\n다음으로 게임 서버를 등록해줍니다. 다음 코드는 게임 서버 자신의 인스턴스를 서버 그룹에 등록하는 동작을 보여줍니다. def register_game_server(): response = client.register_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId, InstanceId=InstanceId, ConnectionInfo=ConnectionInfo ) print(response) update_game_server 함수는 서버 스스로 현재 가용 여부를 보고합니다. FleetIQ 의 HealthCheck 프로세스의 역할도 같이 수행하게 됩니다. def update_game_server(flag): if flag == True: return client.update_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId, HealthCheck=\u0026#34;HEALTHY\u0026#34;, UtilizationStatus=\u0026#34;AVAILABLE\u0026#34; ) else: return client.update_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId, HealthCheck=\u0026#34;HEALTHY\u0026#34;, UtilizationStatus=\u0026#34;UTILIZED\u0026#34; ) deregister_game_server 함수는 게임 서버의 등록을 해제해주는 함수입니다. 본 예제에서는 단일 클라이언트를 처리하는 서버이므로 루프 이후에 해제되고 다음 연결에서 재등록되지만, 실제 구현에서는 클라이언트 핸들링 로직에 알맞게 게임 서버의 라이프사이클을 조절해줍니다. def deregister_game_server(): response = client.deregister_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId ) print(response) 완성된 코드는 다음과 같습니다. import socket import boto3 import requests GameServerGroupName = \u0026#39;GameServerGroups\u0026#39; GameServerId = \u0026#39;game-server-1\u0026#39; InstanceId = requests.get(\u0026#39;http://169.254.169.254/latest/meta-data/instance-id\u0026#39;).text ConnectionInfo = requests.get(\u0026#39;http://169.254.169.254/latest/meta-data/public-hostname\u0026#39;).text client = boto3.client(\u0026#39;gamelift\u0026#39;, \u0026#39;ap-northeast-2\u0026#39;) server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.bind((\u0026#34;\u0026#34;, 5000)) server_socket.listen(5) def list_game_servers(): response = client.list_game_servers( GameServerGroupName=GameServerGroupName ) print(response) return response # Register GameServer def register_game_server(): response = client.register_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId, InstanceId=InstanceId, ConnectionInfo=ConnectionInfo ) print(response) # # Update GameServer def update_game_server(flag): if flag == True: return client.update_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId, HealthCheck=\u0026#34;HEALTHY\u0026#34;, UtilizationStatus=\u0026#34;AVAILABLE\u0026#34; ) else: return client.update_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId, HealthCheck=\u0026#34;HEALTHY\u0026#34;, UtilizationStatus=\u0026#34;UTILIZED\u0026#34; ) # # Deregister GameServer def deregister_game_server(): response = client.deregister_game_server( GameServerGroupName=GameServerGroupName, GameServerId=GameServerId ) print(response) # print(\u0026#34;TCP server waiting for Client on port 5000\u0026#34;) while True: # List Game Server listResponse = list_game_servers() if not \u0026#39;GameServers\u0026#39; in listResponse or not any(server[\u0026#39;GameServerId\u0026#39;] == GameServerId for server in listResponse[\u0026#39;GameServers\u0026#39;]): # Register Game Server to Game Server Group register_game_server() # # Update Game Server Status \u0026#34;AVAILABLE\u0026#34; update_game_server(True) # client_socket, address = server_socket.accept() print(\u0026#34;I got connection from \u0026#34;, address) # Update Game Server Status \u0026#34;UTILIZED\u0026#34; update_game_server(False) # while True: data = client_socket.recv(512).decode() print(\u0026#34;RECEIVED:\u0026#34;, data) if(data == \u0026#39;q\u0026#39; or data == \u0026#39;Q\u0026#39;): client_socket.close() break else: client_socket.send(data.encode()) # Deregister Game Server deregister_game_server() # server_socket.close() print(\u0026#34;SOCKET Closed... End\u0026#34;) 다음으로 클라이언트를 구현해보도록 하겠습니다. "
},
{
	"uri": "/aws-gamelift-sample/ko/gamelift/lab46/",
	"title": "게임 클라이언트 구성 &amp; 게임 플레이!",
	"tags": [],
	"description": "",
	"content": "게임 클라이언트 구성 및 게임 플레이 이 단원의 내용은 FlexMatch 를 활용한 경우와 차이가 있습니다. FlexMatch 버전의 클라이언트 바이너리는 본 실습의 바이너리와 다름에 유의합니다. FlexMatch를 활용한 실습을 원한다면 2단원 실습을 해보실 수 있습니다.\n앞선 실습에서 우리는 GameLift 서비스를 통해 세션을 처리할 게임 서버를 배치했고, 매치메이커 서버를 통해 배치된 GameLift 의 플릿으로 세션을 매칭시켜줄 수 있는 매치 서버 환경을 구성했습니다.\n이제 오목을 플레이할 때가 왔습니다! 와! 너무 신나는군요..!\n실습을 위해서는 Binary 형태로 구성된 게임 클라이언트(Classic/client/GomokuClient.exe)를 이용하거나, 직접 루트 폴더의 GomokuClient 프로젝트를 Visual Studio 에서 빌드합니다. 직접 바이너리를 빌드하신다면 64비트 Release 모드로 빌드하시는 것을 권장드립니다.\nGomokuClient 프로젝트의 루트 디렉토리에 있는 config.ini 파일을 수정합니다. 이전 장에서 생성했던 매치메이커 서버의 EIP 를 설정하고, 연결할 포트를 설정합니다. 클라이언트는 별도의 로그인 기능을 지원하지 않으므로 환경 설정 파일에 로그인할 유저 정보를 입력합니다. 계정이 없다면 새로 회원 가입이 되겠지만, 로그인 정보가 맞지않다면 게임을 실행할 수 없으니 유의해주세요!\nGomokuClient.exe 를 실행합니다. 게임 실행을 위해서는 우클릭 한 뒤 Game Start 버튼을 클릭합니다. 게임을 시작하면 매칭 상대를 탐색합니다.\n매칭이 되면 게임을 즐기실 수 있습니다! 상대를 꺾고 오목의 승자가 되어보세요!\n게임 결과는 데이터베이스에 반영되며, 일전에 구성한 S3 웹사이트 엔드포인트를 통해 확인해보실 수 있습니다. "
},
{
	"uri": "/aws-gamelift-sample/ko/flexmatch/lab26/",
	"title": "매치메이킹 이벤트 구성하기",
	"tags": [],
	"description": "",
	"content": "FlexMatch 매치메이킹 이벤트 구성하기 다음으로 GameLift 서비스를 통해 트리거되는 매치메이킹 이벤트를 핸들링하는 기능을 만들어보겠습니다. GameLift FlexMatch Matchmaking Event 를 통해 Event Notification 을 전달받으면 GameLift API 를 Polling 하는 방식보다 빠르게 매치메이킹 구성을 전달받을 수 있으며 유연하게 사용자 세션을 관리할 수도 있습니다.\n이번 실습에서는 FlexMatch 매치메이킹 이벤트를 이용해서 Event Notification 방식으로 매치메이킹을 구성합니다.\nAmazon SNS 콘솔로 이동합니다.\n왼쪽 메뉴에서 Topic(주제) 을 클릭합니다. Create Topic 버튼을 눌러서 새로운 주제를 생성합니다.\nTopic Type 을 Standard 로 지정합니다. 이름은 다음과 같이 gomoku-match-topic 으로 지정해줍니다.\n하단의 Access Policy 를 수정합니다. Advanced 를 선택하고, JSON 기반 정책에 다음을 입력합니다. 아래 정책은 GameLift 서비스가 SNS 주제에 접근할 수 있도록 해줍니다.\n{ \u0026#34;Version\u0026#34;: \u0026#34;2008-10-17\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;__default_policy_ID\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;__default_statement_ID\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;AWS\u0026#34;: \u0026#34;*\u0026#34; }, \u0026#34;Action\u0026#34;: [ \u0026#34;SNS:GetTopicAttributes\u0026#34;, \u0026#34;SNS:SetTopicAttributes\u0026#34;, \u0026#34;SNS:AddPermission\u0026#34;, \u0026#34;SNS:RemovePermission\u0026#34;, \u0026#34;SNS:DeleteTopic\u0026#34;, \u0026#34;SNS:Subscribe\u0026#34;, \u0026#34;SNS:ListSubscriptionsByTopic\u0026#34;, \u0026#34;SNS:Publish\u0026#34;, \u0026#34;SNS:Receive\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:sns:{your_region}:{your_account}:{your_topic_name}\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;AWS:SourceOwner\u0026#34;: \u0026#34;{your_account}\u0026#34; } } }, { \u0026#34;Sid\u0026#34;: \u0026#34;__console_pub_0\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;gamelift.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;SNS:Publish\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:sns:{your_region}:{your_account}:{your_topic_name}\u0026#34; } ] } 위의 정책에서 {} 로 표기된 부분에는 해당하는 리전, Account 정보, 구성하는 Topic 이름(gomoku-match-topic)을 입력합니다. Account 정보는 콘솔에서 우측 상단에 접속 아이디를 클릭하면 MyAccount 우측의 숫자 배열로 표시됩니다.\n나머지 설정은 그대로 두고 하단의 Create Topic 버튼을 눌러 생성합니다. 다음으로 이벤트를 핸들링할 Lambda 함수를 생성합니다. 이 함수는 위에서 생성한 Amazon SNS 를 구독해서 이전에 생성한 DynamoDB 에 연결 정보를 저장합니다.\nAWS Lambda 콘솔로 이동합니다.\nCreate Function 버튼을 클릭하여 다음 설정으로 새 Lambda 함수 생성을 시작합니다.\nFunction Name : game-match-event Runtime : Python 3.9 Permissions \u0026gt; Execution Role : Create a new role from AWS policy templates Permissions \u0026gt; Role name : BasicLambdaDynamoDBRole Permissions \u0026gt; Policy templates 에서 Simple microservice permissions 을 선택 함수가 생성되면 Add Trigger 버튼을 눌러서 Amazon SNS 서비스를 선택합니다. 앞에서 만들어둔 SNS Topic(gomoku-match-topic) 을 선택합니다. 이 함수는 위에서 생성한 SNS Topic 을 Subscribe 하며, Publish 되는 메시지에 대해 트리거됩니다. 기존 함수 코드를 다음 코드로 변경해줍니다 (MatchEvent.py 파일을 참고합니다). 실습 환경에 알맞은 리전으로 세팅해줍니다. import boto3 import json import time import datetime dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;, region_name=\u0026#39;us-east-1\u0026#39;) ddb_table = dynamodb.Table(\u0026#39;GomokuPlayerInfo\u0026#39;) def lambda_handler(event, context): print(event) sns_message = json.loads(event[\u0026#39;Records\u0026#39;][0][\u0026#39;Sns\u0026#39;][\u0026#39;Message\u0026#39;]) matchevent_status = sns_message[\u0026#39;detail\u0026#39;][\u0026#39;type\u0026#39;] if matchevent_status == \u0026#39;MatchmakingSucceeded\u0026#39;: gamesession_info = sns_message[\u0026#39;detail\u0026#39;][\u0026#39;gameSessionInfo\u0026#39;] address = gamesession_info[\u0026#39;ipAddress\u0026#39;] port = int(gamesession_info[\u0026#39;port\u0026#39;]) players = gamesession_info[\u0026#39;players\u0026#39;] for player in players: player_id = player[\u0026#39;playerId\u0026#39;] if \u0026#39;playerSessionId\u0026#39; in player: player_session_id = player[\u0026#39;playerSessionId\u0026#39;] connection_info = { \u0026#39;IpAddress\u0026#39;: address, \u0026#39;Port\u0026#39;: port, \u0026#39;PlayerSessionId\u0026#39;: player_session_id, \u0026#39;timestamp\u0026#39;: int(time.time()), \u0026#39;status\u0026#39;: \u0026#39;matching\u0026#39; } ddb_table.update_item( TableName=\u0026#34;GomokuPlayerInfo\u0026#34;, Key={ \u0026#39;PlayerName\u0026#39; : player_id }, UpdateExpression=\u0026#34;set ConnectionInfo = :connection_info\u0026#34;, ExpressionAttributeValues={ \u0026#39;:connection_info\u0026#39;: \u0026#34;\u0026#34; + json.dumps(connection_info), }, ReturnValues=\u0026#34;UPDATED_NEW\u0026#34; ) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Hello from Lambda!\u0026#39;) } 함수 코드는 Amazon SNS 에서 트리거된 이벤트에서 매치메이킹 정보를 DynamoDB 로 저장합니다.\n다음으로는 GameLift 가 SNS 로 이벤트를 트리거하도록 구성해봅니다.\nAmazon GameLift 콘솔로 이동합니다.\nMatchmaking Configuration 을 선택합니다. 기존에 만들어둔 GomokuMatchConfig 설정을 선택해줍니다.\nActions \u0026gt; Edit Matchmaking Configuration 버튼을 눌러 설정을 수정합니다.\n다음과 같이 Notification Target 에 앞서 만들어두었던 SNS Topic 의 ARN 을 입력해줍니다.\n이제 GameLift 에서 구성된 매치는 SNS Topic 으로 바로 푸시됩니다. 해당 Topic 을 구동하는 Lambda 함수는 이를 받아서 DynamoDB 에 Connection 정보를 업데이트합니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/fleetiq/lab35/",
	"title": "FleetIQ 기반 클라이언트 생성",
	"tags": [],
	"description": "",
	"content": "Cloud9 기반의 FleetIQ 클라이언트 개발 환경 구축 이번 실습에서는 Cloud 기반의 IDE 인 Cloud9 을 활용하여 간편하게 원격 개발환경을 구축하고 FleetIQ 예제를 위한 클라이언트를 생성해보겠습니다.\nCloud9 을 통해 별다른 로컬 환경의 변경이나 개발 환경 구성의 어려움 없이 일관성있는 온라인 통합 개발 환경을 구축하실 수 있습니다.\nCloud9 콘솔에 접속합니다. (https://ap-northeast-2.console.aws.amazon.com/cloud9/home/product)\n환경의 이름을 FleetIQClient 로 지정합니다.\nEC2 환경으로 지정하고 적절한 인스턴스 타입을 선택합니다. 네트워크 세팅은 기본 VPC 에 위치하도록 구성합니다. Cloud9 개발 환경이 만들어지는 것을 기다립니다. 몇 분 내에 작업은 완료됩니다.\nCloud9 IDE 가 실행되면, client.py 파일을 만들어주고, 다음 소스 코드를 붙여넣습니다.\nimport socket import boto3 client = boto3.client(\u0026#39;gamelift\u0026#39;) # Claim Game Server def claim_game_server(): pass # response = claim_game_server() #endpoint = response[\u0026#39;GameServer\u0026#39;][\u0026#39;ConnectionInfo\u0026#39;] endpoint = \u0026#39;\u0026#39; client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client_socket.connect((endpoint, 5000)) while True: data = input(\u0026#34;SEND(TYPE q or Q to Quit):\u0026#34;) if(data == \u0026#39;q\u0026#39; or data == \u0026#39;Q\u0026#39;): client_socket.send(data.encode()) client_socket.close() break else: client_socket.send(data.encode()) data = client_socket.recv(512).decode() print(\u0026#34;RECEIVED:\u0026#34;, data) print(\u0026#34;Socket Closed... END\u0026#34;) 이 코드는 간단한 TCP 에코 클라이언트를 구현한 모습입니다. 하지만 자세히 보시면 서버의 엔드포인트가 지정되어있지 않습니다. 이제 이 부분을 구현해보겠습니다.\n코드에서 claim_game_server 함수를 구현해주어야 합니다. claimGameServer API 는 GameLift FleetIQ 에게 클라이언트에게 게임 세션을 할당하기에 적합한 서버 인스턴스를 요청하는 API 입니다. 클라이언트는 게임 서버에 연결하기 위해 해당 API 를 통해 요청을 구축해주기만 하면 됩니다. claim_game_server 함수에 다음과 같은 코드를 구성합니다. def claim_game_server(): response = client.claim_game_server( GameServerGroupName=\u0026#39;GameServerGroups\u0026#39; ) print(response) return response 함수의 리턴 값은 할당된 게임 서버의 엔드포인트 정보를 갖습니다. 기존 소스에 주석을 제거하고 endpoint 에 응답값을 다음과 같이 할당합니다.\nendpoint = response[\u0026#39;GameServer\u0026#39;][\u0026#39;ConnectionInfo\u0026#39;] 완성된 코드는 다음과 같습니다 import socket import boto3 client = boto3.client(\u0026#39;gamelift\u0026#39;, \u0026#39;ap-northeast-2\u0026#39;) # Claim Game Server def claim_game_server(): response = client.claim_game_server( GameServerGroupName=\u0026#39;GameServerGroups\u0026#39; ) print(response) return response # response = claim_game_server() endpoint = response[\u0026#39;GameServer\u0026#39;][\u0026#39;ConnectionInfo\u0026#39;] client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client_socket.connect((endpoint, 5000)) while True: data = input(\u0026#34;SEND(TYPE q or Q to Quit):\u0026#34;) if(data == \u0026#39;q\u0026#39; or data == \u0026#39;Q\u0026#39;): client_socket.send(data.encode()) client_socket.close() break else: client_socket.send(data.encode()) data = client_socket.recv(512).decode() print(\u0026#34;RECEIVED:\u0026#34;, data) print(\u0026#34;Socket Closed... END\u0026#34;) 실습에서는 FleetIQ API 구동을 학습하기 위한 목적으로 간단한 TCP 연결만을 구성하지만, 코드가 간단하지만 보다 복잡한 게임 로직으로 실습을 진행하셔도 좋습니다.\n이제 이전에 만들었던 서버와 클라이언트가 어떻게 상호작용하는지 알아보도록 하겠습니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/flexmatch/lab27/",
	"title": "FlexMatch 클라이언트와 연결",
	"tags": [],
	"description": "",
	"content": "FlexMatch 를 이용한 게임 클라이언트와 연동 FlexMatch 기능을 사용하기 위해서는 서버 또는 클라이언트 레벨에서 FlexMatch 기능을 사용하도록 일부 바이너리의 수정이 필요합니다. 이번 실습에서는 게임 클라이언트가 조금 전에 우리가 만든 Lambda 함수를 호출하고, Lambda 함수가 서버리스 형태로 FlexMatch 기능을 통해 클라이언트의 세션을 적합한 게임 서버로 매칭시켜 줍니다.\n우리는 Windows OS 에서 동작하는 오목 클라이언트를 사용할 것입니다.\n게임 클라이언트는 Outbound TCP 커넥션을 2개 맺습니다. (방화벽 설정이 필요하다면 설정해줍니다.)\n다운로드 받은 실습 파일에서 bin/FlexMatch/Client_player1 폴더로 이동합니다.\n해당 Client_player1 폴더 내의 config.ini 파일의 수정이 필요합니다.\n앞선 Section 5의 마지막 단계에서 확인한 API Gateway URL을 MATCH_SERVER_API값에 입력합니다.\nPLAYER_NAME과 PLAYER_PASSWD를 (임의로) 지정합니다.\n게임 클라이언트(GomokuClient.exe)를 실행합니다. 아래의 스크립 캡처와 같이 실행될 것입니다.\n다른 플레이어를 실행해야 합니다. 다운로드 받은 실습 파일에서 bin/FlexMatch/Client_player2 폴더로 이동하여 config.ini 파일을 앞서와 같이 수정하고 player2를 실행합니다.\n두 개의 게임 화면에서 우클릭한 뒤 Start 하세요!\n이미 졌다고 판단된다면 우클릭한 뒤 Give up을 할 수 있습니다.\nDynamoDB의 Score를 임의로 변경하여 Matchmaking을 테스트해 보십시요\nGameLift 및 FlexMatch 를 활용한 풀스택 게임 서버 구축 단계는 여기까지입니다.\n이후 실습 과정 및 FleetIQ 를 통해 GameLift 의 Advanced 한 내용들에 대해 학습하실 수 있습니다. :)\n"
},
{
	"uri": "/aws-gamelift-sample/ko/appendix/",
	"title": "부록(Appendix)",
	"tags": [],
	"description": "",
	"content": "GameLift 바이너리 빌드 GameLift 의 게임 서버 및 클라이언트 바이너리는 모두 Visual Studio 2015 기반에서 제작되었습니다. 해당 버전과 호환되는 Visual Studio 환경에서 빌드하시기를 권고드립니다.\n제공된 소스 코드에서 GomokuClient 또는 GomokuServer 폴더 중 빌드하고자 하는 프로젝트를 선택합니다.\n프로젝트를 Visual Studio 환경에서 오픈합니다. 프로젝트는 Nuget 패키지 기반 Dependency 를 갖고 있으며, AWS SDK 들에 대해 DLL Dependency 를 갖고 있습니다.\n다음과 같이 프로젝트 세팅을 구성하고 빌드합니다.\n빌드 환경을 Release 로 구성하시는 것을 권고드립니다. 기본 폴더에 관련 Dependency 를 이미 포함하고 있습니다. 만약 문제가 생긴다면 Release 폴더의 dll 파일 등을 복사하여 debug 폴더에도 동일한 환경을 구성 후 테스트해보실 수 있습니다.\nGameLift Classic 프로젝트와 GameLift FlexMatch 프로젝트는 서로 다른 버전의 SDK 를 사용하므로 구현 상에 차이가 있습니다. 각 환경에 맞게 프로젝트를 빌드하시는 것을 권고드립니다.\nGameLift 게임 서버 접속 GameLift 에서 게임 서버 리소스를 관리하지만, 디버깅이나 로그 분석 등의 이유로 게임 서버에 직접 접속해야할 수 있습니다. 이럴 때 다음 지침을 참고합니다.\n아래 커맨드 사용을 위해서는 CLI 가 필요합니다.\nFleetID 로부터 해당 플릿에 구성된 인스턴스 목록을 조회합니다. aws gamelift describe-instances --fleet-id fleet-4b7fc542-cb08-4f65-908c-737f64ca2e8f --region ap-northeast-2 위의 커맨드로 알게된 Fleet ID 와 인스턴스 ID 를 기반으로 다음 명령어를 수행합니다. aws gamelift get-instance-access --fleet-id fleet-4b7fc542-cb08-4f65-908c-737f64ca2e8f --instance-id i-031278fb03cf29d35 --region ap-northeast-2 도출된 인스턴스 접속 정보를 이용해 RDP 또는 SSH 로 인스턴스에 접근합니다. 이 때 인스턴스의 포트 정보가 접근 가능한지 확인합니다. 만약 포트가 열려있지 않다면 플릿을 편집하여 포트 구성을 수정할 수 있습니다. 위의 그림에서 인스턴스는 RDP 포트에 대해 허용하고 있는 모습입니다. 환경에 맞게 구성합니다.\n"
},
{
	"uri": "/aws-gamelift-sample/ko/flexmatch/lab28/",
	"title": "매치메이킹 이벤트 분석하기",
	"tags": [],
	"description": "",
	"content": "FlexMatch 매치메이킹 이벤트 분석하기 게임을 준비할 때, 게임이 작동하는 것 그 자체가 목적이 될 수는 없습니다. 그만큼 중요한 것이 바로 게임의 운영이죠. FlexMatch 는 매치메이킹 이벤트를 제공하며, GameLift 가 처리하는 티켓의 관련 이벤트들을 발생시킵니다. 이를 통해서, 새로 런칭한 게임의 매치메이킹이 버그없이 잘 동작하고 있는지, 올바른 상대와 적절하게 매칭이 되고 있는지 모니터링하실 수 있으며, 때로는 트러블슈팅 및 디버깅의 목적으로 사용하실 수도 있습니다.\n이번 실습에서는 FlexMatch 매치메이킹 이벤트를 이용해서 매치 티켓 정보를 로깅하고, CloudWatch Logs 를 통해서 세션 매칭 양상을 손쉽게 분석해보는 연습을 해보겠습니다.\nCloudWatch Logs 는 로그에 대해 준실시간성으로 모니터링할 수 있는 간편한 도구이고, 이를 Logs Insight 를 통해서 별도의 리소스 구성 없이도 편하게 모니터링 시스템을 구축할 수 있습니다. 실습을 통해 연습해볼 수 있는 좋은 기회가 되겠습니다!\n먼저 FlexMatch 매치메이킹 이벤트를 처리할 Lambda 함수를 생성합니다. 바로 로그 그룹을 생성할 수도 있지만, Lambda 함수 구성을 통해 실습 도중 이벤트 데이터를 응용해서 사용해보시길 바랍니다.\nLambda 함수의 이름은 game-flexmatch-event 로 지정하시고, 런타임 환경은 Python 3.9 버전으로 구성합니다. Permission 으로는 CloudWatch Logs 에 로그를 기록할 수 있는 권한이 필요하며, 실습의 편의를 위해 기본 설정(basic Lambda permission)으로 쉽게 구현하실 수 있습니다.\n함수의 코드는 별도 파일로 제공되지는 않습니다. 다음 소스 코드를 복사 붙여넣기 하시고, 원하시는대로 가공하실 수 있습니다. import json def lambda_handler(event, context): eventType = event[\u0026#39;detail\u0026#39;][\u0026#39;type\u0026#39;] if (eventType == \u0026#34;MatchmakingSucceeded\u0026#34;): a = event[\u0026#39;detail\u0026#39;][\u0026#39;gameSessionInfo\u0026#39;][\u0026#39;players\u0026#39;][0][\u0026#39;playerId\u0026#39;] b = event[\u0026#39;detail\u0026#39;][\u0026#39;gameSessionInfo\u0026#39;][\u0026#39;players\u0026#39;][1][\u0026#39;playerId\u0026#39;] print(\u0026#34;Matchmaking: \u0026#34; + a + \u0026#34;,\u0026#34; + b) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Hello from Lambda!\u0026#39;) } 코드는 매치메이킹 이벤트의 티켓 타입을 검사하고, 매칭이 성공할 경우 매칭 정보를 로그로 기록합니다. Lambda 에서 작성된 Log 는 기본적으로 CloudWatch Logs 로 출력이 구성됩니다.\n다음으로 트리거 구성을 위해 CloudWatch 콘솔에 접속합니다. (https://console.aws.amazon.com/cloudwatch)\n좌측 메뉴의 CloudWatch Events 를 선택하고, \u0026ldquo;시작하기\u0026rdquo; 버튼 또는 \u0026ldquo;규칙 생성\u0026rdquo; 메뉴를 클릭합니다.\n다음과 같이 이벤트를 트리거하는 규칙을 생성합니다. 대상 서비스로 SNS 주제 등 다양한 서비스를 구성할 수 있지만, 본 실습에서는 조금 전에 만든 Lambda 함수(game-flexmatch-event)를 선택해줍니다.\n적당한 이름으로 이벤트를 다음과 같이 생성해주면 준비는 끝납니다. 이제 다시 \u0026ldquo;오목\u0026rdquo; 게임을 플레이하도록 합니다. 게임을 플레이하면서 CloudWatch Logs 를 확인해보면 다음과 같이 CloudWatch Events 에서 Lambda 함수로 트리거되는 이벤트에 대한 정보가 로깅되는 것을 확인해보실 수 있습니다. 다음으로 왼쪽 메뉴의 Logs Insight 메뉴를 클릭해줍니다.\n다음 쿼리는 로그 중에서 매치메이킹 결과를 raw data 형태로 필터링해서 제공합니다.\nfields @timestamp, @message | filter @message like /Matchmaking:/ | sort @timestamp desc | limit 20 다음과 같은 결과를 확인해보실 수 있습니다.\n다음 쿼리는 최근 매치메이킹 결과에 대해서 집계해주는 통계 쿼리를 제공해줍니다. stats count(*) by @message | filter @message like /Matchmaking:/ | sort @timestamp desc | limit 20 결과는 다음과 같습니다.\n실습에서는 간단한 예제를 따라해보았습니다. 게임을 더 플레이해보시고, 더 유용한 통계 쿼리를 쉽게 만들어보실 수 있습니다. 이러한 이벤트 기능 등을 활용하면 게임 런칭 초반 세션 매칭 관련 밸런싱을 하는데 큰 도움을 줄 수 있습니다. "
},
{
	"uri": "/aws-gamelift-sample/ko/fleetiq/lab36/",
	"title": "서버 - 클라이언트 연동",
	"tags": [],
	"description": "",
	"content": "FleetIQ 기반의 서버 - 클라이언트 연동 서버 인스턴스에 연결된 Cloud9 IDE 로 이동합니다.\n다음 그림과 같이 Python 3 로 서버 스크립트를 작동시킵니다.\n서버가 실행되면 클라이언트의 연결을 대기하게 됩니다. 다음으로 클라이언트 실행을 위해 클라이언트 Cloud9 IDE 로 이동합니다.\n같은 방법으로 클라이언트 스크립트를 실행시켜 줍니다. 다음과 같이 에코 클라이언트가 호출되게 됩니다! 이제 서버와 TCP 소켓 통신을 확인해보세요.\n주목할 수 있는 점은 FleetIQ 서비스로부터 연결 정보를 받아서 Fiesta 알고리즘에 기반한 효율적인 인스턴스로 세션 연결을 구성했다는 점입니다. 이제 독립형 FleetIQ 기능을 통해 세션 기반 게임 서비스를 유연하고 비용 효율적으로 구축하실 수 있습니다. "
},
{
	"uri": "/aws-gamelift-sample/ko/flexmatch/lab29/",
	"title": "FlexMatch 룰셋 테스트",
	"tags": [],
	"description": "",
	"content": "FlexMatch 규칙세트 사용 이번 장에서는 몇가지 테스트해볼 수 있는 만들어진 규칙세트를 제공합니다. 뛰어난 매치메이킹은 유저들의 흥미를 돋구워주는데 충분하죠! 오목이라는 1:1 게임의 특성 상 많은 규칙을 테스트해보기는 쉽지 않지만, 그래도 게임에 적용시켜볼 수 있을만한 규칙의 예제는 여러분의 게임에 영감을 줄 수 있습니다.\n규칙을 적용하기 위해서는 다음과 같이 매치메이킹 규칙 세트를 새로 만들어줍니다.\n이후 이미 만들어진 규칙 구성 세트가 해당 규칙을 가리키도록 변경해줍니다. 이를 통해 쉽게 규칙 세트를 테스트해볼 수 있습니다.\n기본 룰셋 : 기본 룰셋의 경우, 실습에 이미 적용되어 있습니다. 2-5 파트를 참고합니다.\n점수에 엄격한 룰셋 : 일부 게임의 경우 점수 매칭이 엄격하게 적용되어질 수 있습니다. 가령, 승-패가 기록되고 명확히 우승을 가려야하는 토너먼트 방식의 게임이라면, 점수에 엄격하게 상대를 매칭시켜줘야 할 필요가 있습니다.\n{ \u0026#34;name\u0026#34;: \u0026#34;Strict Matching\u0026#34;, \u0026#34;ruleLanguageVersion\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;playerAttributes\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;score\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;number\u0026#34;, \u0026#34;default\u0026#34; : 1000 } ], \u0026#34;teams\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;player\u0026#34;, \u0026#34;minPlayers\u0026#34;: 1, \u0026#34;maxPlayers\u0026#34;: 1, \u0026#34;quantity\u0026#34;: 2 }], \u0026#34;rules\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;SameScore\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Only match players when they have same score\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;comparison\u0026#34;, \u0026#34;operation\u0026#34;: \u0026#34;=\u0026#34;, \u0026#34;measurements\u0026#34;: [\u0026#34;flatten(teams[*].players.attributes[score])\u0026#34;] }] } 지연 시간을 제한하는 룰셋 : 스피드 매치가 중요한 게임의 경우 지연 시간을 중시한 Ruleset 을 테스트해볼 수 있습니다. 또한 글로벌 서버를 운영하는 경우에도, 지연 시간을 제한하면 유저들에게 쾌적한 매칭 경험을 제공해줄 수 있습니다. { \u0026#34;name\u0026#34;: \u0026#34;Fast Game\u0026#34;, \u0026#34;ruleLanguageVersion\u0026#34;: \u0026#34;1.0\u0026#34;, \u0026#34;playerAttributes\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;score\u0026#34;, \u0026#34;type\u0026#34; : \u0026#34;number\u0026#34;, \u0026#34;default\u0026#34; : 1000 } ], \u0026#34;teams\u0026#34; : [ { \u0026#34;name\u0026#34; : \u0026#34;blue\u0026#34;, \u0026#34;maxPlayers\u0026#34; : 1, \u0026#34;minPlayers\u0026#34; : 1 }, { \u0026#34;name\u0026#34; : \u0026#34;red\u0026#34;, \u0026#34;maxPlayers\u0026#34; : 1, \u0026#34;minPlayers\u0026#34; : 1 } ], \u0026#34;rules\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;FastConnection\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Prefer matches with fast player connections first\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;latency\u0026#34;, \u0026#34;maxLatency\u0026#34;: 50 }], \u0026#34;expansions\u0026#34;: [{ \u0026#34;target\u0026#34;: \u0026#34;rules[FastConnection].maxLatency\u0026#34;, \u0026#34;steps\u0026#34;: [{ \u0026#34;waitTimeSeconds\u0026#34;: 10, \u0026#34;value\u0026#34;: 100 }, { \u0026#34;waitTimeSeconds\u0026#34;: 20, \u0026#34;value\u0026#34;: 150 }] }] } 이 외에도 다양한 커스텀 룰셋을 구성하고 테스트할 수 있습니다. 보다 자세한 규칙 세트 작성 방법은 다음 링크를 참고합니다. https://docs.aws.amazon.com/ko_kr/gamelift/latest/developerguide/match-rulesets.html\n"
},
{
	"uri": "/aws-gamelift-sample/ko/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/aws-gamelift-sample/ko/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]